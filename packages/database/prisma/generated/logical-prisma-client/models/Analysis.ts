import type {
	ModifiedAlternative,
	BiasedTerm,
	BiasedMetaphor,
	AdditionalContextEvaluation,
	ImpactAnalysis,
} from '../../json-types'
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/*
 * This file exports the `Analysis` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/client'
import type * as $Enums from '../enums.ts'
import type * as Prisma from '../internal/prismaNamespace.ts'
/**
 * Model Analysis
 * @
 * @allow ('all', auth() == User)
 */
export type AnalysisModel =
	runtime.Types.Result.DefaultSelection<Prisma.$AnalysisPayload>
export type AggregateAnalysis = {
	_count: AnalysisCountAggregateOutputType | null
	_min: AnalysisMinAggregateOutputType | null
	_max: AnalysisMaxAggregateOutputType | null
}
export type AnalysisMinAggregateOutputType = {
	originalText: string | null
	conclusion: string | null
	id: string | null
	name: string | null
	visibility: $Enums.Visibility | null
	status: $Enums.AnalysisStatus | null
	inputSource: $Enums.InputSource | null
	presetId: string | null
	userId: string | null
	createdAt: Date | null
	updatedAt: Date | null
}
export type AnalysisMaxAggregateOutputType = {
	originalText: string | null
	conclusion: string | null
	id: string | null
	name: string | null
	visibility: $Enums.Visibility | null
	status: $Enums.AnalysisStatus | null
	inputSource: $Enums.InputSource | null
	presetId: string | null
	userId: string | null
	createdAt: Date | null
	updatedAt: Date | null
}
export type AnalysisCountAggregateOutputType = {
	originalText: number
	modifiedTextAlternatives: number
	biasedTerms: number
	biasedMetaphors: number
	additionalContextEvaluation: number
	impactAnalysis: number
	conclusion: number
	id: number
	name: number
	visibility: number
	status: number
	inputSource: number
	presetId: number
	userId: number
	createdAt: number
	updatedAt: number
	_all: number
}
export type AnalysisMinAggregateInputType = {
	originalText?: true
	conclusion?: true
	id?: true
	name?: true
	visibility?: true
	status?: true
	inputSource?: true
	presetId?: true
	userId?: true
	createdAt?: true
	updatedAt?: true
}
export type AnalysisMaxAggregateInputType = {
	originalText?: true
	conclusion?: true
	id?: true
	name?: true
	visibility?: true
	status?: true
	inputSource?: true
	presetId?: true
	userId?: true
	createdAt?: true
	updatedAt?: true
}
export type AnalysisCountAggregateInputType = {
	originalText?: true
	modifiedTextAlternatives?: true
	biasedTerms?: true
	biasedMetaphors?: true
	additionalContextEvaluation?: true
	impactAnalysis?: true
	conclusion?: true
	id?: true
	name?: true
	visibility?: true
	status?: true
	inputSource?: true
	presetId?: true
	userId?: true
	createdAt?: true
	updatedAt?: true
	_all?: true
}
export type AnalysisAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Analysis to aggregate.
	 */
	where?: Prisma.AnalysisWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Analyses to fetch.
	 */
	orderBy?:
		| Prisma.AnalysisOrderByWithRelationInput
		| Prisma.AnalysisOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.AnalysisWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Analyses from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Analyses.
	 */
	skip?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned Analyses
	 **/
	_count?: true | AnalysisCountAggregateInputType
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: AnalysisMinAggregateInputType
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: AnalysisMaxAggregateInputType
}
export type GetAnalysisAggregateType<T extends AnalysisAggregateArgs> = {
	[P in keyof T & keyof AggregateAnalysis]: P extends '_count' | 'count'
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateAnalysis[P]>
		: Prisma.GetScalarType<T[P], AggregateAnalysis[P]>
}
export type AnalysisGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.AnalysisWhereInput
	orderBy?:
		| Prisma.AnalysisOrderByWithAggregationInput
		| Prisma.AnalysisOrderByWithAggregationInput[]
	by: Prisma.AnalysisScalarFieldEnum[] | Prisma.AnalysisScalarFieldEnum
	having?: Prisma.AnalysisScalarWhereWithAggregatesInput
	take?: number
	skip?: number
	_count?: AnalysisCountAggregateInputType | true
	_min?: AnalysisMinAggregateInputType
	_max?: AnalysisMaxAggregateInputType
}
export type AnalysisGroupByOutputType = {
	originalText: string
	modifiedTextAlternatives: ModifiedAlternative[]
	biasedTerms: BiasedTerm[]
	biasedMetaphors: BiasedMetaphor[]
	additionalContextEvaluation: AdditionalContextEvaluation | null
	impactAnalysis: ImpactAnalysis | null
	conclusion: string | null
	id: string
	name: string | null
	visibility: $Enums.Visibility
	status: $Enums.AnalysisStatus
	inputSource: $Enums.InputSource
	presetId: string
	userId: string | null
	createdAt: Date
	updatedAt: Date
	_count: AnalysisCountAggregateOutputType | null
	_min: AnalysisMinAggregateOutputType | null
	_max: AnalysisMaxAggregateOutputType | null
}
type GetAnalysisGroupByPayload<T extends AnalysisGroupByArgs> =
	Prisma.PrismaPromise<
		Array<
			Prisma.PickEnumerable<AnalysisGroupByOutputType, T['by']> & {
				[P in keyof T &
					keyof AnalysisGroupByOutputType]: P extends '_count'
					? T[P] extends boolean
						? number
						: Prisma.GetScalarType<
								T[P],
								AnalysisGroupByOutputType[P]
							>
					: Prisma.GetScalarType<T[P], AnalysisGroupByOutputType[P]>
			}
		>
	>
export type AnalysisWhereInput = {
	AND?: Prisma.AnalysisWhereInput | Prisma.AnalysisWhereInput[]
	OR?: Prisma.AnalysisWhereInput[]
	NOT?: Prisma.AnalysisWhereInput | Prisma.AnalysisWhereInput[]
	originalText?: Prisma.StringFilter<'Analysis'> | string
	modifiedTextAlternatives?: Prisma.JsonFilter<'Analysis'>
	biasedTerms?: Prisma.JsonFilter<'Analysis'>
	biasedMetaphors?: Prisma.JsonFilter<'Analysis'>
	additionalContextEvaluation?: Prisma.JsonNullableFilter<'Analysis'>
	impactAnalysis?: Prisma.JsonNullableFilter<'Analysis'>
	conclusion?: Prisma.StringNullableFilter<'Analysis'> | string | null
	id?: Prisma.StringFilter<'Analysis'> | string
	name?: Prisma.StringNullableFilter<'Analysis'> | string | null
	visibility?: Prisma.EnumVisibilityFilter<'Analysis'> | $Enums.Visibility
	status?: Prisma.EnumAnalysisStatusFilter<'Analysis'> | $Enums.AnalysisStatus
	inputSource?: Prisma.EnumInputSourceFilter<'Analysis'> | $Enums.InputSource
	presetId?: Prisma.StringFilter<'Analysis'> | string
	userId?: Prisma.StringNullableFilter<'Analysis'> | string | null
	createdAt?: Prisma.DateTimeFilter<'Analysis'> | Date | string
	updatedAt?: Prisma.DateTimeFilter<'Analysis'> | Date | string
	Preset?: Prisma.XOR<
		Prisma.PresetScalarRelationFilter,
		Prisma.PresetWhereInput
	>
	User?: Prisma.XOR<
		Prisma.UserNullableScalarRelationFilter,
		Prisma.UserWhereInput
	> | null
}
export type AnalysisOrderByWithRelationInput = {
	originalText?: Prisma.SortOrder
	modifiedTextAlternatives?: Prisma.SortOrder
	biasedTerms?: Prisma.SortOrder
	biasedMetaphors?: Prisma.SortOrder
	additionalContextEvaluation?: Prisma.SortOrderInput | Prisma.SortOrder
	impactAnalysis?: Prisma.SortOrderInput | Prisma.SortOrder
	conclusion?: Prisma.SortOrderInput | Prisma.SortOrder
	id?: Prisma.SortOrder
	name?: Prisma.SortOrderInput | Prisma.SortOrder
	visibility?: Prisma.SortOrder
	status?: Prisma.SortOrder
	inputSource?: Prisma.SortOrder
	presetId?: Prisma.SortOrder
	userId?: Prisma.SortOrderInput | Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
	Preset?: Prisma.PresetOrderByWithRelationInput
	User?: Prisma.UserOrderByWithRelationInput
	_relevance?: Prisma.AnalysisOrderByRelevanceInput
}
export type AnalysisWhereUniqueInput = Prisma.AtLeast<
	{
		id?: string
		AND?: Prisma.AnalysisWhereInput | Prisma.AnalysisWhereInput[]
		OR?: Prisma.AnalysisWhereInput[]
		NOT?: Prisma.AnalysisWhereInput | Prisma.AnalysisWhereInput[]
		originalText?: Prisma.StringFilter<'Analysis'> | string
		modifiedTextAlternatives?: Prisma.JsonFilter<'Analysis'>
		biasedTerms?: Prisma.JsonFilter<'Analysis'>
		biasedMetaphors?: Prisma.JsonFilter<'Analysis'>
		additionalContextEvaluation?: Prisma.JsonNullableFilter<'Analysis'>
		impactAnalysis?: Prisma.JsonNullableFilter<'Analysis'>
		conclusion?: Prisma.StringNullableFilter<'Analysis'> | string | null
		name?: Prisma.StringNullableFilter<'Analysis'> | string | null
		visibility?: Prisma.EnumVisibilityFilter<'Analysis'> | $Enums.Visibility
		status?:
			| Prisma.EnumAnalysisStatusFilter<'Analysis'>
			| $Enums.AnalysisStatus
		inputSource?:
			| Prisma.EnumInputSourceFilter<'Analysis'>
			| $Enums.InputSource
		presetId?: Prisma.StringFilter<'Analysis'> | string
		userId?: Prisma.StringNullableFilter<'Analysis'> | string | null
		createdAt?: Prisma.DateTimeFilter<'Analysis'> | Date | string
		updatedAt?: Prisma.DateTimeFilter<'Analysis'> | Date | string
		Preset?: Prisma.XOR<
			Prisma.PresetScalarRelationFilter,
			Prisma.PresetWhereInput
		>
		User?: Prisma.XOR<
			Prisma.UserNullableScalarRelationFilter,
			Prisma.UserWhereInput
		> | null
	},
	'id'
>
export type AnalysisOrderByWithAggregationInput = {
	originalText?: Prisma.SortOrder
	modifiedTextAlternatives?: Prisma.SortOrder
	biasedTerms?: Prisma.SortOrder
	biasedMetaphors?: Prisma.SortOrder
	additionalContextEvaluation?: Prisma.SortOrderInput | Prisma.SortOrder
	impactAnalysis?: Prisma.SortOrderInput | Prisma.SortOrder
	conclusion?: Prisma.SortOrderInput | Prisma.SortOrder
	id?: Prisma.SortOrder
	name?: Prisma.SortOrderInput | Prisma.SortOrder
	visibility?: Prisma.SortOrder
	status?: Prisma.SortOrder
	inputSource?: Prisma.SortOrder
	presetId?: Prisma.SortOrder
	userId?: Prisma.SortOrderInput | Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
	_count?: Prisma.AnalysisCountOrderByAggregateInput
	_max?: Prisma.AnalysisMaxOrderByAggregateInput
	_min?: Prisma.AnalysisMinOrderByAggregateInput
}
export type AnalysisScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.AnalysisScalarWhereWithAggregatesInput
		| Prisma.AnalysisScalarWhereWithAggregatesInput[]
	OR?: Prisma.AnalysisScalarWhereWithAggregatesInput[]
	NOT?:
		| Prisma.AnalysisScalarWhereWithAggregatesInput
		| Prisma.AnalysisScalarWhereWithAggregatesInput[]
	originalText?: Prisma.StringWithAggregatesFilter<'Analysis'> | string
	modifiedTextAlternatives?: Prisma.JsonWithAggregatesFilter<'Analysis'>
	biasedTerms?: Prisma.JsonWithAggregatesFilter<'Analysis'>
	biasedMetaphors?: Prisma.JsonWithAggregatesFilter<'Analysis'>
	additionalContextEvaluation?: Prisma.JsonNullableWithAggregatesFilter<'Analysis'>
	impactAnalysis?: Prisma.JsonNullableWithAggregatesFilter<'Analysis'>
	conclusion?:
		| Prisma.StringNullableWithAggregatesFilter<'Analysis'>
		| string
		| null
	id?: Prisma.StringWithAggregatesFilter<'Analysis'> | string
	name?: Prisma.StringNullableWithAggregatesFilter<'Analysis'> | string | null
	visibility?:
		| Prisma.EnumVisibilityWithAggregatesFilter<'Analysis'>
		| $Enums.Visibility
	status?:
		| Prisma.EnumAnalysisStatusWithAggregatesFilter<'Analysis'>
		| $Enums.AnalysisStatus
	inputSource?:
		| Prisma.EnumInputSourceWithAggregatesFilter<'Analysis'>
		| $Enums.InputSource
	presetId?: Prisma.StringWithAggregatesFilter<'Analysis'> | string
	userId?:
		| Prisma.StringNullableWithAggregatesFilter<'Analysis'>
		| string
		| null
	createdAt?: Prisma.DateTimeWithAggregatesFilter<'Analysis'> | Date | string
	updatedAt?: Prisma.DateTimeWithAggregatesFilter<'Analysis'> | Date | string
}
export type AnalysisCreateInput = {
	originalText: string
	modifiedTextAlternatives: ModifiedAlternative[]
	biasedTerms: BiasedTerm[]
	biasedMetaphors: BiasedMetaphor[]
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: string | null
	id?: string
	name?: string | null
	visibility?: $Enums.Visibility
	status?: $Enums.AnalysisStatus
	inputSource?: $Enums.InputSource
	createdAt?: Date | string
	updatedAt?: Date | string
	Preset: Prisma.PresetCreateNestedOneWithoutAnalysisInput
	User?: Prisma.UserCreateNestedOneWithoutAnalysesInput
}
export type AnalysisUncheckedCreateInput = {
	originalText: string
	modifiedTextAlternatives: ModifiedAlternative[]
	biasedTerms: BiasedTerm[]
	biasedMetaphors: BiasedMetaphor[]
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: string | null
	id?: string
	name?: string | null
	visibility?: $Enums.Visibility
	status?: $Enums.AnalysisStatus
	inputSource?: $Enums.InputSource
	presetId: string
	userId?: string | null
	createdAt?: Date | string
	updatedAt?: Date | string
}
export type AnalysisUpdateInput = {
	originalText?: Prisma.StringFieldUpdateOperationsInput | string
	modifiedTextAlternatives?: ModifiedAlternative[] | runtime.Types.Skip
	biasedTerms?: BiasedTerm[] | runtime.Types.Skip
	biasedMetaphors?: BiasedMetaphor[] | runtime.Types.Skip
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	id?: Prisma.StringFieldUpdateOperationsInput | string
	name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	visibility?:
		| Prisma.EnumVisibilityFieldUpdateOperationsInput
		| $Enums.Visibility
	status?:
		| Prisma.EnumAnalysisStatusFieldUpdateOperationsInput
		| $Enums.AnalysisStatus
	inputSource?:
		| Prisma.EnumInputSourceFieldUpdateOperationsInput
		| $Enums.InputSource
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	Preset?: Prisma.PresetUpdateOneRequiredWithoutAnalysisNestedInput
	User?: Prisma.UserUpdateOneWithoutAnalysesNestedInput
}
export type AnalysisUncheckedUpdateInput = {
	originalText?: Prisma.StringFieldUpdateOperationsInput | string
	modifiedTextAlternatives?: ModifiedAlternative[] | runtime.Types.Skip
	biasedTerms?: BiasedTerm[] | runtime.Types.Skip
	biasedMetaphors?: BiasedMetaphor[] | runtime.Types.Skip
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	id?: Prisma.StringFieldUpdateOperationsInput | string
	name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	visibility?:
		| Prisma.EnumVisibilityFieldUpdateOperationsInput
		| $Enums.Visibility
	status?:
		| Prisma.EnumAnalysisStatusFieldUpdateOperationsInput
		| $Enums.AnalysisStatus
	inputSource?:
		| Prisma.EnumInputSourceFieldUpdateOperationsInput
		| $Enums.InputSource
	presetId?: Prisma.StringFieldUpdateOperationsInput | string
	userId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}
export type AnalysisCreateManyInput = {
	originalText: string
	modifiedTextAlternatives: ModifiedAlternative[]
	biasedTerms: BiasedTerm[]
	biasedMetaphors: BiasedMetaphor[]
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: string | null
	id?: string
	name?: string | null
	visibility?: $Enums.Visibility
	status?: $Enums.AnalysisStatus
	inputSource?: $Enums.InputSource
	presetId: string
	userId?: string | null
	createdAt?: Date | string
	updatedAt?: Date | string
}
export type AnalysisUpdateManyMutationInput = {
	originalText?: Prisma.StringFieldUpdateOperationsInput | string
	modifiedTextAlternatives?: ModifiedAlternative[] | runtime.Types.Skip
	biasedTerms?: BiasedTerm[] | runtime.Types.Skip
	biasedMetaphors?: BiasedMetaphor[] | runtime.Types.Skip
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	id?: Prisma.StringFieldUpdateOperationsInput | string
	name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	visibility?:
		| Prisma.EnumVisibilityFieldUpdateOperationsInput
		| $Enums.Visibility
	status?:
		| Prisma.EnumAnalysisStatusFieldUpdateOperationsInput
		| $Enums.AnalysisStatus
	inputSource?:
		| Prisma.EnumInputSourceFieldUpdateOperationsInput
		| $Enums.InputSource
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}
export type AnalysisUncheckedUpdateManyInput = {
	originalText?: Prisma.StringFieldUpdateOperationsInput | string
	modifiedTextAlternatives?: ModifiedAlternative[] | runtime.Types.Skip
	biasedTerms?: BiasedTerm[] | runtime.Types.Skip
	biasedMetaphors?: BiasedMetaphor[] | runtime.Types.Skip
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	id?: Prisma.StringFieldUpdateOperationsInput | string
	name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	visibility?:
		| Prisma.EnumVisibilityFieldUpdateOperationsInput
		| $Enums.Visibility
	status?:
		| Prisma.EnumAnalysisStatusFieldUpdateOperationsInput
		| $Enums.AnalysisStatus
	inputSource?:
		| Prisma.EnumInputSourceFieldUpdateOperationsInput
		| $Enums.InputSource
	presetId?: Prisma.StringFieldUpdateOperationsInput | string
	userId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}
export type AnalysisListRelationFilter = {
	every?: Prisma.AnalysisWhereInput
	some?: Prisma.AnalysisWhereInput
	none?: Prisma.AnalysisWhereInput
}
export type AnalysisOrderByRelationAggregateInput = {
	_count?: Prisma.SortOrder
}
export type AnalysisOrderByRelevanceInput = {
	fields:
		| Prisma.AnalysisOrderByRelevanceFieldEnum
		| Prisma.AnalysisOrderByRelevanceFieldEnum[]
	sort: Prisma.SortOrder
	search: string
}
export type AnalysisCountOrderByAggregateInput = {
	originalText?: Prisma.SortOrder
	modifiedTextAlternatives?: Prisma.SortOrder
	biasedTerms?: Prisma.SortOrder
	biasedMetaphors?: Prisma.SortOrder
	additionalContextEvaluation?: Prisma.SortOrder
	impactAnalysis?: Prisma.SortOrder
	conclusion?: Prisma.SortOrder
	id?: Prisma.SortOrder
	name?: Prisma.SortOrder
	visibility?: Prisma.SortOrder
	status?: Prisma.SortOrder
	inputSource?: Prisma.SortOrder
	presetId?: Prisma.SortOrder
	userId?: Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
}
export type AnalysisMaxOrderByAggregateInput = {
	originalText?: Prisma.SortOrder
	conclusion?: Prisma.SortOrder
	id?: Prisma.SortOrder
	name?: Prisma.SortOrder
	visibility?: Prisma.SortOrder
	status?: Prisma.SortOrder
	inputSource?: Prisma.SortOrder
	presetId?: Prisma.SortOrder
	userId?: Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
}
export type AnalysisMinOrderByAggregateInput = {
	originalText?: Prisma.SortOrder
	conclusion?: Prisma.SortOrder
	id?: Prisma.SortOrder
	name?: Prisma.SortOrder
	visibility?: Prisma.SortOrder
	status?: Prisma.SortOrder
	inputSource?: Prisma.SortOrder
	presetId?: Prisma.SortOrder
	userId?: Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
}
export type AnalysisCreateNestedManyWithoutUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.AnalysisCreateWithoutUserInput,
				Prisma.AnalysisUncheckedCreateWithoutUserInput
		  >
		| Prisma.AnalysisCreateWithoutUserInput[]
		| Prisma.AnalysisUncheckedCreateWithoutUserInput[]
	connectOrCreate?:
		| Prisma.AnalysisCreateOrConnectWithoutUserInput
		| Prisma.AnalysisCreateOrConnectWithoutUserInput[]
	createMany?: Prisma.AnalysisCreateManyUserInputEnvelope
	connect?:
		| Prisma.AnalysisWhereUniqueInput
		| Prisma.AnalysisWhereUniqueInput[]
}
export type AnalysisUncheckedCreateNestedManyWithoutUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.AnalysisCreateWithoutUserInput,
				Prisma.AnalysisUncheckedCreateWithoutUserInput
		  >
		| Prisma.AnalysisCreateWithoutUserInput[]
		| Prisma.AnalysisUncheckedCreateWithoutUserInput[]
	connectOrCreate?:
		| Prisma.AnalysisCreateOrConnectWithoutUserInput
		| Prisma.AnalysisCreateOrConnectWithoutUserInput[]
	createMany?: Prisma.AnalysisCreateManyUserInputEnvelope
	connect?:
		| Prisma.AnalysisWhereUniqueInput
		| Prisma.AnalysisWhereUniqueInput[]
}
export type AnalysisUpdateManyWithoutUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.AnalysisCreateWithoutUserInput,
				Prisma.AnalysisUncheckedCreateWithoutUserInput
		  >
		| Prisma.AnalysisCreateWithoutUserInput[]
		| Prisma.AnalysisUncheckedCreateWithoutUserInput[]
	connectOrCreate?:
		| Prisma.AnalysisCreateOrConnectWithoutUserInput
		| Prisma.AnalysisCreateOrConnectWithoutUserInput[]
	upsert?:
		| Prisma.AnalysisUpsertWithWhereUniqueWithoutUserInput
		| Prisma.AnalysisUpsertWithWhereUniqueWithoutUserInput[]
	createMany?: Prisma.AnalysisCreateManyUserInputEnvelope
	set?: Prisma.AnalysisWhereUniqueInput | Prisma.AnalysisWhereUniqueInput[]
	disconnect?:
		| Prisma.AnalysisWhereUniqueInput
		| Prisma.AnalysisWhereUniqueInput[]
	delete?: Prisma.AnalysisWhereUniqueInput | Prisma.AnalysisWhereUniqueInput[]
	connect?:
		| Prisma.AnalysisWhereUniqueInput
		| Prisma.AnalysisWhereUniqueInput[]
	update?:
		| Prisma.AnalysisUpdateWithWhereUniqueWithoutUserInput
		| Prisma.AnalysisUpdateWithWhereUniqueWithoutUserInput[]
	updateMany?:
		| Prisma.AnalysisUpdateManyWithWhereWithoutUserInput
		| Prisma.AnalysisUpdateManyWithWhereWithoutUserInput[]
	deleteMany?:
		| Prisma.AnalysisScalarWhereInput
		| Prisma.AnalysisScalarWhereInput[]
}
export type AnalysisUncheckedUpdateManyWithoutUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.AnalysisCreateWithoutUserInput,
				Prisma.AnalysisUncheckedCreateWithoutUserInput
		  >
		| Prisma.AnalysisCreateWithoutUserInput[]
		| Prisma.AnalysisUncheckedCreateWithoutUserInput[]
	connectOrCreate?:
		| Prisma.AnalysisCreateOrConnectWithoutUserInput
		| Prisma.AnalysisCreateOrConnectWithoutUserInput[]
	upsert?:
		| Prisma.AnalysisUpsertWithWhereUniqueWithoutUserInput
		| Prisma.AnalysisUpsertWithWhereUniqueWithoutUserInput[]
	createMany?: Prisma.AnalysisCreateManyUserInputEnvelope
	set?: Prisma.AnalysisWhereUniqueInput | Prisma.AnalysisWhereUniqueInput[]
	disconnect?:
		| Prisma.AnalysisWhereUniqueInput
		| Prisma.AnalysisWhereUniqueInput[]
	delete?: Prisma.AnalysisWhereUniqueInput | Prisma.AnalysisWhereUniqueInput[]
	connect?:
		| Prisma.AnalysisWhereUniqueInput
		| Prisma.AnalysisWhereUniqueInput[]
	update?:
		| Prisma.AnalysisUpdateWithWhereUniqueWithoutUserInput
		| Prisma.AnalysisUpdateWithWhereUniqueWithoutUserInput[]
	updateMany?:
		| Prisma.AnalysisUpdateManyWithWhereWithoutUserInput
		| Prisma.AnalysisUpdateManyWithWhereWithoutUserInput[]
	deleteMany?:
		| Prisma.AnalysisScalarWhereInput
		| Prisma.AnalysisScalarWhereInput[]
}
export type EnumVisibilityFieldUpdateOperationsInput = {
	set?: $Enums.Visibility
}
export type EnumAnalysisStatusFieldUpdateOperationsInput = {
	set?: $Enums.AnalysisStatus
}
export type EnumInputSourceFieldUpdateOperationsInput = {
	set?: $Enums.InputSource
}
export type AnalysisCreateNestedManyWithoutPresetInput = {
	create?:
		| Prisma.XOR<
				Prisma.AnalysisCreateWithoutPresetInput,
				Prisma.AnalysisUncheckedCreateWithoutPresetInput
		  >
		| Prisma.AnalysisCreateWithoutPresetInput[]
		| Prisma.AnalysisUncheckedCreateWithoutPresetInput[]
	connectOrCreate?:
		| Prisma.AnalysisCreateOrConnectWithoutPresetInput
		| Prisma.AnalysisCreateOrConnectWithoutPresetInput[]
	createMany?: Prisma.AnalysisCreateManyPresetInputEnvelope
	connect?:
		| Prisma.AnalysisWhereUniqueInput
		| Prisma.AnalysisWhereUniqueInput[]
}
export type AnalysisUncheckedCreateNestedManyWithoutPresetInput = {
	create?:
		| Prisma.XOR<
				Prisma.AnalysisCreateWithoutPresetInput,
				Prisma.AnalysisUncheckedCreateWithoutPresetInput
		  >
		| Prisma.AnalysisCreateWithoutPresetInput[]
		| Prisma.AnalysisUncheckedCreateWithoutPresetInput[]
	connectOrCreate?:
		| Prisma.AnalysisCreateOrConnectWithoutPresetInput
		| Prisma.AnalysisCreateOrConnectWithoutPresetInput[]
	createMany?: Prisma.AnalysisCreateManyPresetInputEnvelope
	connect?:
		| Prisma.AnalysisWhereUniqueInput
		| Prisma.AnalysisWhereUniqueInput[]
}
export type AnalysisUpdateManyWithoutPresetNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.AnalysisCreateWithoutPresetInput,
				Prisma.AnalysisUncheckedCreateWithoutPresetInput
		  >
		| Prisma.AnalysisCreateWithoutPresetInput[]
		| Prisma.AnalysisUncheckedCreateWithoutPresetInput[]
	connectOrCreate?:
		| Prisma.AnalysisCreateOrConnectWithoutPresetInput
		| Prisma.AnalysisCreateOrConnectWithoutPresetInput[]
	upsert?:
		| Prisma.AnalysisUpsertWithWhereUniqueWithoutPresetInput
		| Prisma.AnalysisUpsertWithWhereUniqueWithoutPresetInput[]
	createMany?: Prisma.AnalysisCreateManyPresetInputEnvelope
	set?: Prisma.AnalysisWhereUniqueInput | Prisma.AnalysisWhereUniqueInput[]
	disconnect?:
		| Prisma.AnalysisWhereUniqueInput
		| Prisma.AnalysisWhereUniqueInput[]
	delete?: Prisma.AnalysisWhereUniqueInput | Prisma.AnalysisWhereUniqueInput[]
	connect?:
		| Prisma.AnalysisWhereUniqueInput
		| Prisma.AnalysisWhereUniqueInput[]
	update?:
		| Prisma.AnalysisUpdateWithWhereUniqueWithoutPresetInput
		| Prisma.AnalysisUpdateWithWhereUniqueWithoutPresetInput[]
	updateMany?:
		| Prisma.AnalysisUpdateManyWithWhereWithoutPresetInput
		| Prisma.AnalysisUpdateManyWithWhereWithoutPresetInput[]
	deleteMany?:
		| Prisma.AnalysisScalarWhereInput
		| Prisma.AnalysisScalarWhereInput[]
}
export type AnalysisUncheckedUpdateManyWithoutPresetNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.AnalysisCreateWithoutPresetInput,
				Prisma.AnalysisUncheckedCreateWithoutPresetInput
		  >
		| Prisma.AnalysisCreateWithoutPresetInput[]
		| Prisma.AnalysisUncheckedCreateWithoutPresetInput[]
	connectOrCreate?:
		| Prisma.AnalysisCreateOrConnectWithoutPresetInput
		| Prisma.AnalysisCreateOrConnectWithoutPresetInput[]
	upsert?:
		| Prisma.AnalysisUpsertWithWhereUniqueWithoutPresetInput
		| Prisma.AnalysisUpsertWithWhereUniqueWithoutPresetInput[]
	createMany?: Prisma.AnalysisCreateManyPresetInputEnvelope
	set?: Prisma.AnalysisWhereUniqueInput | Prisma.AnalysisWhereUniqueInput[]
	disconnect?:
		| Prisma.AnalysisWhereUniqueInput
		| Prisma.AnalysisWhereUniqueInput[]
	delete?: Prisma.AnalysisWhereUniqueInput | Prisma.AnalysisWhereUniqueInput[]
	connect?:
		| Prisma.AnalysisWhereUniqueInput
		| Prisma.AnalysisWhereUniqueInput[]
	update?:
		| Prisma.AnalysisUpdateWithWhereUniqueWithoutPresetInput
		| Prisma.AnalysisUpdateWithWhereUniqueWithoutPresetInput[]
	updateMany?:
		| Prisma.AnalysisUpdateManyWithWhereWithoutPresetInput
		| Prisma.AnalysisUpdateManyWithWhereWithoutPresetInput[]
	deleteMany?:
		| Prisma.AnalysisScalarWhereInput
		| Prisma.AnalysisScalarWhereInput[]
}
export type AnalysisCreateWithoutUserInput = {
	originalText: string
	modifiedTextAlternatives: ModifiedAlternative[]
	biasedTerms: BiasedTerm[]
	biasedMetaphors: BiasedMetaphor[]
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: string | null
	id?: string
	name?: string | null
	visibility?: $Enums.Visibility
	status?: $Enums.AnalysisStatus
	inputSource?: $Enums.InputSource
	createdAt?: Date | string
	updatedAt?: Date | string
	Preset: Prisma.PresetCreateNestedOneWithoutAnalysisInput
}
export type AnalysisUncheckedCreateWithoutUserInput = {
	originalText: string
	modifiedTextAlternatives: ModifiedAlternative[]
	biasedTerms: BiasedTerm[]
	biasedMetaphors: BiasedMetaphor[]
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: string | null
	id?: string
	name?: string | null
	visibility?: $Enums.Visibility
	status?: $Enums.AnalysisStatus
	inputSource?: $Enums.InputSource
	presetId: string
	createdAt?: Date | string
	updatedAt?: Date | string
}
export type AnalysisCreateOrConnectWithoutUserInput = {
	where: Prisma.AnalysisWhereUniqueInput
	create: Prisma.XOR<
		Prisma.AnalysisCreateWithoutUserInput,
		Prisma.AnalysisUncheckedCreateWithoutUserInput
	>
}
export type AnalysisCreateManyUserInputEnvelope = {
	data:
		| Prisma.AnalysisCreateManyUserInput
		| Prisma.AnalysisCreateManyUserInput[]
	skipDuplicates?: boolean
}
export type AnalysisUpsertWithWhereUniqueWithoutUserInput = {
	where: Prisma.AnalysisWhereUniqueInput
	update: Prisma.XOR<
		Prisma.AnalysisUpdateWithoutUserInput,
		Prisma.AnalysisUncheckedUpdateWithoutUserInput
	>
	create: Prisma.XOR<
		Prisma.AnalysisCreateWithoutUserInput,
		Prisma.AnalysisUncheckedCreateWithoutUserInput
	>
}
export type AnalysisUpdateWithWhereUniqueWithoutUserInput = {
	where: Prisma.AnalysisWhereUniqueInput
	data: Prisma.XOR<
		Prisma.AnalysisUpdateWithoutUserInput,
		Prisma.AnalysisUncheckedUpdateWithoutUserInput
	>
}
export type AnalysisUpdateManyWithWhereWithoutUserInput = {
	where: Prisma.AnalysisScalarWhereInput
	data: Prisma.XOR<
		Prisma.AnalysisUpdateManyMutationInput,
		Prisma.AnalysisUncheckedUpdateManyWithoutUserInput
	>
}
export type AnalysisScalarWhereInput = {
	AND?: Prisma.AnalysisScalarWhereInput | Prisma.AnalysisScalarWhereInput[]
	OR?: Prisma.AnalysisScalarWhereInput[]
	NOT?: Prisma.AnalysisScalarWhereInput | Prisma.AnalysisScalarWhereInput[]
	originalText?: Prisma.StringFilter<'Analysis'> | string
	modifiedTextAlternatives?: Prisma.JsonFilter<'Analysis'>
	biasedTerms?: Prisma.JsonFilter<'Analysis'>
	biasedMetaphors?: Prisma.JsonFilter<'Analysis'>
	additionalContextEvaluation?: Prisma.JsonNullableFilter<'Analysis'>
	impactAnalysis?: Prisma.JsonNullableFilter<'Analysis'>
	conclusion?: Prisma.StringNullableFilter<'Analysis'> | string | null
	id?: Prisma.StringFilter<'Analysis'> | string
	name?: Prisma.StringNullableFilter<'Analysis'> | string | null
	visibility?: Prisma.EnumVisibilityFilter<'Analysis'> | $Enums.Visibility
	status?: Prisma.EnumAnalysisStatusFilter<'Analysis'> | $Enums.AnalysisStatus
	inputSource?: Prisma.EnumInputSourceFilter<'Analysis'> | $Enums.InputSource
	presetId?: Prisma.StringFilter<'Analysis'> | string
	userId?: Prisma.StringNullableFilter<'Analysis'> | string | null
	createdAt?: Prisma.DateTimeFilter<'Analysis'> | Date | string
	updatedAt?: Prisma.DateTimeFilter<'Analysis'> | Date | string
}
export type AnalysisCreateWithoutPresetInput = {
	originalText: string
	modifiedTextAlternatives: ModifiedAlternative[]
	biasedTerms: BiasedTerm[]
	biasedMetaphors: BiasedMetaphor[]
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: string | null
	id?: string
	name?: string | null
	visibility?: $Enums.Visibility
	status?: $Enums.AnalysisStatus
	inputSource?: $Enums.InputSource
	createdAt?: Date | string
	updatedAt?: Date | string
	User?: Prisma.UserCreateNestedOneWithoutAnalysesInput
}
export type AnalysisUncheckedCreateWithoutPresetInput = {
	originalText: string
	modifiedTextAlternatives: ModifiedAlternative[]
	biasedTerms: BiasedTerm[]
	biasedMetaphors: BiasedMetaphor[]
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: string | null
	id?: string
	name?: string | null
	visibility?: $Enums.Visibility
	status?: $Enums.AnalysisStatus
	inputSource?: $Enums.InputSource
	userId?: string | null
	createdAt?: Date | string
	updatedAt?: Date | string
}
export type AnalysisCreateOrConnectWithoutPresetInput = {
	where: Prisma.AnalysisWhereUniqueInput
	create: Prisma.XOR<
		Prisma.AnalysisCreateWithoutPresetInput,
		Prisma.AnalysisUncheckedCreateWithoutPresetInput
	>
}
export type AnalysisCreateManyPresetInputEnvelope = {
	data:
		| Prisma.AnalysisCreateManyPresetInput
		| Prisma.AnalysisCreateManyPresetInput[]
	skipDuplicates?: boolean
}
export type AnalysisUpsertWithWhereUniqueWithoutPresetInput = {
	where: Prisma.AnalysisWhereUniqueInput
	update: Prisma.XOR<
		Prisma.AnalysisUpdateWithoutPresetInput,
		Prisma.AnalysisUncheckedUpdateWithoutPresetInput
	>
	create: Prisma.XOR<
		Prisma.AnalysisCreateWithoutPresetInput,
		Prisma.AnalysisUncheckedCreateWithoutPresetInput
	>
}
export type AnalysisUpdateWithWhereUniqueWithoutPresetInput = {
	where: Prisma.AnalysisWhereUniqueInput
	data: Prisma.XOR<
		Prisma.AnalysisUpdateWithoutPresetInput,
		Prisma.AnalysisUncheckedUpdateWithoutPresetInput
	>
}
export type AnalysisUpdateManyWithWhereWithoutPresetInput = {
	where: Prisma.AnalysisScalarWhereInput
	data: Prisma.XOR<
		Prisma.AnalysisUpdateManyMutationInput,
		Prisma.AnalysisUncheckedUpdateManyWithoutPresetInput
	>
}
export type AnalysisCreateManyUserInput = {
	originalText: string
	modifiedTextAlternatives: ModifiedAlternative[]
	biasedTerms: BiasedTerm[]
	biasedMetaphors: BiasedMetaphor[]
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: string | null
	id?: string
	name?: string | null
	visibility?: $Enums.Visibility
	status?: $Enums.AnalysisStatus
	inputSource?: $Enums.InputSource
	presetId: string
	createdAt?: Date | string
	updatedAt?: Date | string
}
export type AnalysisUpdateWithoutUserInput = {
	originalText?: Prisma.StringFieldUpdateOperationsInput | string
	modifiedTextAlternatives?: ModifiedAlternative[] | runtime.Types.Skip
	biasedTerms?: BiasedTerm[] | runtime.Types.Skip
	biasedMetaphors?: BiasedMetaphor[] | runtime.Types.Skip
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	id?: Prisma.StringFieldUpdateOperationsInput | string
	name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	visibility?:
		| Prisma.EnumVisibilityFieldUpdateOperationsInput
		| $Enums.Visibility
	status?:
		| Prisma.EnumAnalysisStatusFieldUpdateOperationsInput
		| $Enums.AnalysisStatus
	inputSource?:
		| Prisma.EnumInputSourceFieldUpdateOperationsInput
		| $Enums.InputSource
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	Preset?: Prisma.PresetUpdateOneRequiredWithoutAnalysisNestedInput
}
export type AnalysisUncheckedUpdateWithoutUserInput = {
	originalText?: Prisma.StringFieldUpdateOperationsInput | string
	modifiedTextAlternatives?: ModifiedAlternative[] | runtime.Types.Skip
	biasedTerms?: BiasedTerm[] | runtime.Types.Skip
	biasedMetaphors?: BiasedMetaphor[] | runtime.Types.Skip
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	id?: Prisma.StringFieldUpdateOperationsInput | string
	name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	visibility?:
		| Prisma.EnumVisibilityFieldUpdateOperationsInput
		| $Enums.Visibility
	status?:
		| Prisma.EnumAnalysisStatusFieldUpdateOperationsInput
		| $Enums.AnalysisStatus
	inputSource?:
		| Prisma.EnumInputSourceFieldUpdateOperationsInput
		| $Enums.InputSource
	presetId?: Prisma.StringFieldUpdateOperationsInput | string
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}
export type AnalysisUncheckedUpdateManyWithoutUserInput = {
	originalText?: Prisma.StringFieldUpdateOperationsInput | string
	modifiedTextAlternatives?: ModifiedAlternative[] | runtime.Types.Skip
	biasedTerms?: BiasedTerm[] | runtime.Types.Skip
	biasedMetaphors?: BiasedMetaphor[] | runtime.Types.Skip
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	id?: Prisma.StringFieldUpdateOperationsInput | string
	name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	visibility?:
		| Prisma.EnumVisibilityFieldUpdateOperationsInput
		| $Enums.Visibility
	status?:
		| Prisma.EnumAnalysisStatusFieldUpdateOperationsInput
		| $Enums.AnalysisStatus
	inputSource?:
		| Prisma.EnumInputSourceFieldUpdateOperationsInput
		| $Enums.InputSource
	presetId?: Prisma.StringFieldUpdateOperationsInput | string
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}
export type AnalysisCreateManyPresetInput = {
	originalText: string
	modifiedTextAlternatives: ModifiedAlternative[]
	biasedTerms: BiasedTerm[]
	biasedMetaphors: BiasedMetaphor[]
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: string | null
	id?: string
	name?: string | null
	visibility?: $Enums.Visibility
	status?: $Enums.AnalysisStatus
	inputSource?: $Enums.InputSource
	userId?: string | null
	createdAt?: Date | string
	updatedAt?: Date | string
}
export type AnalysisUpdateWithoutPresetInput = {
	originalText?: Prisma.StringFieldUpdateOperationsInput | string
	modifiedTextAlternatives?: ModifiedAlternative[] | runtime.Types.Skip
	biasedTerms?: BiasedTerm[] | runtime.Types.Skip
	biasedMetaphors?: BiasedMetaphor[] | runtime.Types.Skip
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	id?: Prisma.StringFieldUpdateOperationsInput | string
	name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	visibility?:
		| Prisma.EnumVisibilityFieldUpdateOperationsInput
		| $Enums.Visibility
	status?:
		| Prisma.EnumAnalysisStatusFieldUpdateOperationsInput
		| $Enums.AnalysisStatus
	inputSource?:
		| Prisma.EnumInputSourceFieldUpdateOperationsInput
		| $Enums.InputSource
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	User?: Prisma.UserUpdateOneWithoutAnalysesNestedInput
}
export type AnalysisUncheckedUpdateWithoutPresetInput = {
	originalText?: Prisma.StringFieldUpdateOperationsInput | string
	modifiedTextAlternatives?: ModifiedAlternative[] | runtime.Types.Skip
	biasedTerms?: BiasedTerm[] | runtime.Types.Skip
	biasedMetaphors?: BiasedMetaphor[] | runtime.Types.Skip
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	id?: Prisma.StringFieldUpdateOperationsInput | string
	name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	visibility?:
		| Prisma.EnumVisibilityFieldUpdateOperationsInput
		| $Enums.Visibility
	status?:
		| Prisma.EnumAnalysisStatusFieldUpdateOperationsInput
		| $Enums.AnalysisStatus
	inputSource?:
		| Prisma.EnumInputSourceFieldUpdateOperationsInput
		| $Enums.InputSource
	userId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}
export type AnalysisUncheckedUpdateManyWithoutPresetInput = {
	originalText?: Prisma.StringFieldUpdateOperationsInput | string
	modifiedTextAlternatives?: ModifiedAlternative[] | runtime.Types.Skip
	biasedTerms?: BiasedTerm[] | runtime.Types.Skip
	biasedMetaphors?: BiasedMetaphor[] | runtime.Types.Skip
	additionalContextEvaluation?:
		| AdditionalContextEvaluation
		| null
		| runtime.Types.Skip
	impactAnalysis?: ImpactAnalysis | null | runtime.Types.Skip
	conclusion?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	id?: Prisma.StringFieldUpdateOperationsInput | string
	name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	visibility?:
		| Prisma.EnumVisibilityFieldUpdateOperationsInput
		| $Enums.Visibility
	status?:
		| Prisma.EnumAnalysisStatusFieldUpdateOperationsInput
		| $Enums.AnalysisStatus
	inputSource?:
		| Prisma.EnumInputSourceFieldUpdateOperationsInput
		| $Enums.InputSource
	userId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}
export type AnalysisSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		originalText?: boolean
		modifiedTextAlternatives?: boolean
		biasedTerms?: boolean
		biasedMetaphors?: boolean
		additionalContextEvaluation?: boolean
		impactAnalysis?: boolean
		conclusion?: boolean
		id?: boolean
		name?: boolean
		visibility?: boolean
		status?: boolean
		inputSource?: boolean
		presetId?: boolean
		userId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		Preset?: boolean | Prisma.PresetDefaultArgs<ExtArgs>
		User?: boolean | Prisma.Analysis$UserArgs<ExtArgs>
	},
	ExtArgs['result']['analysis']
>
export type AnalysisSelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		originalText?: boolean
		modifiedTextAlternatives?: boolean
		biasedTerms?: boolean
		biasedMetaphors?: boolean
		additionalContextEvaluation?: boolean
		impactAnalysis?: boolean
		conclusion?: boolean
		id?: boolean
		name?: boolean
		visibility?: boolean
		status?: boolean
		inputSource?: boolean
		presetId?: boolean
		userId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		Preset?: boolean | Prisma.PresetDefaultArgs<ExtArgs>
		User?: boolean | Prisma.Analysis$UserArgs<ExtArgs>
	},
	ExtArgs['result']['analysis']
>
export type AnalysisSelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		originalText?: boolean
		modifiedTextAlternatives?: boolean
		biasedTerms?: boolean
		biasedMetaphors?: boolean
		additionalContextEvaluation?: boolean
		impactAnalysis?: boolean
		conclusion?: boolean
		id?: boolean
		name?: boolean
		visibility?: boolean
		status?: boolean
		inputSource?: boolean
		presetId?: boolean
		userId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		Preset?: boolean | Prisma.PresetDefaultArgs<ExtArgs>
		User?: boolean | Prisma.Analysis$UserArgs<ExtArgs>
	},
	ExtArgs['result']['analysis']
>
export type AnalysisSelectScalar = {
	originalText?: boolean
	modifiedTextAlternatives?: boolean
	biasedTerms?: boolean
	biasedMetaphors?: boolean
	additionalContextEvaluation?: boolean
	impactAnalysis?: boolean
	conclusion?: boolean
	id?: boolean
	name?: boolean
	visibility?: boolean
	status?: boolean
	inputSource?: boolean
	presetId?: boolean
	userId?: boolean
	createdAt?: boolean
	updatedAt?: boolean
}
export type AnalysisOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	| 'originalText'
	| 'modifiedTextAlternatives'
	| 'biasedTerms'
	| 'biasedMetaphors'
	| 'additionalContextEvaluation'
	| 'impactAnalysis'
	| 'conclusion'
	| 'id'
	| 'name'
	| 'visibility'
	| 'status'
	| 'inputSource'
	| 'presetId'
	| 'userId'
	| 'createdAt'
	| 'updatedAt',
	ExtArgs['result']['analysis']
>
export type AnalysisInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	Preset?: boolean | Prisma.PresetDefaultArgs<ExtArgs>
	User?: boolean | Prisma.Analysis$UserArgs<ExtArgs>
}
export type AnalysisIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	Preset?: boolean | Prisma.PresetDefaultArgs<ExtArgs>
	User?: boolean | Prisma.Analysis$UserArgs<ExtArgs>
}
export type AnalysisIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	Preset?: boolean | Prisma.PresetDefaultArgs<ExtArgs>
	User?: boolean | Prisma.Analysis$UserArgs<ExtArgs>
}
export type $AnalysisPayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: 'Analysis'
	objects: {
		Preset: Prisma.$PresetPayload<ExtArgs>
		User: Prisma.$UserPayload<ExtArgs> | null
	}
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			originalText: string
			/**
			 * @json
			 */
			modifiedTextAlternatives: ModifiedAlternative[]
			/**
			 * @json
			 */
			biasedTerms: BiasedTerm[]
			/**
			 * @json
			 */
			biasedMetaphors: BiasedMetaphor[]
			/**
			 * @json
			 */
			additionalContextEvaluation: AdditionalContextEvaluation | null
			/**
			 * @json
			 */
			impactAnalysis: ImpactAnalysis | null
			conclusion: string | null
			id: string
			name: string | null
			visibility: $Enums.Visibility
			status: $Enums.AnalysisStatus
			inputSource: $Enums.InputSource
			presetId: string
			userId: string | null
			createdAt: Date
			updatedAt: Date
		},
		ExtArgs['result']['analysis']
	>
	composites: {}
}
export type AnalysisGetPayload<
	S extends boolean | null | undefined | AnalysisDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$AnalysisPayload, S>
export type AnalysisCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<AnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
	select?: AnalysisCountAggregateInputType | true
}

export interface AnalysisDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>['model']['Analysis']
		meta: { name: 'Analysis' }
	}
	/**
	 * Fields of the Analysis model
	 */
	readonly fields: AnalysisFieldRefs
	/**
	 * Find zero or one Analysis that matches the filter.
	 * @param {AnalysisFindUniqueArgs} args - Arguments to find a Analysis
	 * @example
	 * // Get one Analysis
	 * const analysis = await prisma.analysis.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends AnalysisFindUniqueArgs>(
		args: Prisma.SelectSubset<T, AnalysisFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__AnalysisClient<
		runtime.Types.Result.GetResult<
			Prisma.$AnalysisPayload<ExtArgs>,
			T,
			'findUnique',
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Find one Analysis that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {AnalysisFindUniqueOrThrowArgs} args - Arguments to find a Analysis
	 * @example
	 * // Get one Analysis
	 * const analysis = await prisma.analysis.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends AnalysisFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, AnalysisFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__AnalysisClient<
		runtime.Types.Result.GetResult<
			Prisma.$AnalysisPayload<ExtArgs>,
			T,
			'findUniqueOrThrow',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Find the first Analysis that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AnalysisFindFirstArgs} args - Arguments to find a Analysis
	 * @example
	 * // Get one Analysis
	 * const analysis = await prisma.analysis.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends AnalysisFindFirstArgs>(
		args?: Prisma.SelectSubset<T, AnalysisFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__AnalysisClient<
		runtime.Types.Result.GetResult<
			Prisma.$AnalysisPayload<ExtArgs>,
			T,
			'findFirst',
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Find the first Analysis that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AnalysisFindFirstOrThrowArgs} args - Arguments to find a Analysis
	 * @example
	 * // Get one Analysis
	 * const analysis = await prisma.analysis.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends AnalysisFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, AnalysisFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__AnalysisClient<
		runtime.Types.Result.GetResult<
			Prisma.$AnalysisPayload<ExtArgs>,
			T,
			'findFirstOrThrow',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Find zero or more Analyses that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all Analyses
	 * const analyses = await prisma.analysis.findMany()
	 *
	 * // Get first 10 Analyses
	 * const analyses = await prisma.analysis.findMany({ take: 10 })
	 *
	 * // Only select the `originalText`
	 * const analysisWithOriginalTextOnly = await prisma.analysis.findMany({ select: { originalText: true } })
	 */
	findMany<T extends AnalysisFindManyArgs>(
		args?: Prisma.SelectSubset<T, AnalysisFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$AnalysisPayload<ExtArgs>,
			T,
			'findMany',
			GlobalOmitOptions
		>
	>
	/**
	 * Create a Analysis.
	 * @param {AnalysisCreateArgs} args - Arguments to create a Analysis.
	 * @example
	 * // Create one Analysis
	 * const Analysis = await prisma.analysis.create({
	 *   data: {
	 *     // ... data to create a Analysis
	 *   }
	 * })
	 */
	create<T extends AnalysisCreateArgs>(
		args: Prisma.SelectSubset<T, AnalysisCreateArgs<ExtArgs>>,
	): Prisma.Prisma__AnalysisClient<
		runtime.Types.Result.GetResult<
			Prisma.$AnalysisPayload<ExtArgs>,
			T,
			'create',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Create many Analyses.
	 * @param {AnalysisCreateManyArgs} args - Arguments to create many Analyses.
	 * @example
	 * // Create many Analyses
	 * const analysis = await prisma.analysis.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 */
	createMany<T extends AnalysisCreateManyArgs>(
		args?: Prisma.SelectSubset<T, AnalysisCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>
	/**
	 * Create many Analyses and returns the data saved in the database.
	 * @param {AnalysisCreateManyAndReturnArgs} args - Arguments to create many Analyses.
	 * @example
	 * // Create many Analyses
	 * const analysis = await prisma.analysis.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many Analyses and only return the `originalText`
	 * const analysisWithOriginalTextOnly = await prisma.analysis.createManyAndReturn({
	 *   select: { originalText: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 */
	createManyAndReturn<T extends AnalysisCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<T, AnalysisCreateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$AnalysisPayload<ExtArgs>,
			T,
			'createManyAndReturn',
			GlobalOmitOptions
		>
	>
	/**
	 * Delete a Analysis.
	 * @param {AnalysisDeleteArgs} args - Arguments to delete one Analysis.
	 * @example
	 * // Delete one Analysis
	 * const Analysis = await prisma.analysis.delete({
	 *   where: {
	 *     // ... filter to delete one Analysis
	 *   }
	 * })
	 */
	delete<T extends AnalysisDeleteArgs>(
		args: Prisma.SelectSubset<T, AnalysisDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__AnalysisClient<
		runtime.Types.Result.GetResult<
			Prisma.$AnalysisPayload<ExtArgs>,
			T,
			'delete',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Update one Analysis.
	 * @param {AnalysisUpdateArgs} args - Arguments to update one Analysis.
	 * @example
	 * // Update one Analysis
	 * const analysis = await prisma.analysis.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 */
	update<T extends AnalysisUpdateArgs>(
		args: Prisma.SelectSubset<T, AnalysisUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__AnalysisClient<
		runtime.Types.Result.GetResult<
			Prisma.$AnalysisPayload<ExtArgs>,
			T,
			'update',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Delete zero or more Analyses.
	 * @param {AnalysisDeleteManyArgs} args - Arguments to filter Analyses to delete.
	 * @example
	 * // Delete a few Analyses
	 * const { count } = await prisma.analysis.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	deleteMany<T extends AnalysisDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, AnalysisDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>
	/**
	 * Update zero or more Analyses.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AnalysisUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many Analyses
	 * const analysis = await prisma.analysis.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 */
	updateMany<T extends AnalysisUpdateManyArgs>(
		args: Prisma.SelectSubset<T, AnalysisUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>
	/**
	 * Update zero or more Analyses and returns the data updated in the database.
	 * @param {AnalysisUpdateManyAndReturnArgs} args - Arguments to update many Analyses.
	 * @example
	 * // Update many Analyses
	 * const analysis = await prisma.analysis.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more Analyses and only return the `originalText`
	 * const analysisWithOriginalTextOnly = await prisma.analysis.updateManyAndReturn({
	 *   select: { originalText: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 */
	updateManyAndReturn<T extends AnalysisUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<T, AnalysisUpdateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$AnalysisPayload<ExtArgs>,
			T,
			'updateManyAndReturn',
			GlobalOmitOptions
		>
	>
	/**
	 * Create or update one Analysis.
	 * @param {AnalysisUpsertArgs} args - Arguments to update or create a Analysis.
	 * @example
	 * // Update or create a Analysis
	 * const analysis = await prisma.analysis.upsert({
	 *   create: {
	 *     // ... data to create a Analysis
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the Analysis we want to update
	 *   }
	 * })
	 */
	upsert<T extends AnalysisUpsertArgs>(
		args: Prisma.SelectSubset<T, AnalysisUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__AnalysisClient<
		runtime.Types.Result.GetResult<
			Prisma.$AnalysisPayload<ExtArgs>,
			T,
			'upsert',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Count the number of Analyses.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AnalysisCountArgs} args - Arguments to filter Analyses to count.
	 * @example
	 * // Count the number of Analyses
	 * const count = await prisma.analysis.count({
	 *   where: {
	 *     // ... the filter for the Analyses we want to count
	 *   }
	 * })
	 */
	count<T extends AnalysisCountArgs>(
		args?: Prisma.Subset<T, AnalysisCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<'select', any>
			? T['select'] extends true
				? number
				: Prisma.GetScalarType<
						T['select'],
						AnalysisCountAggregateOutputType
					>
			: number
	>
	/**
	 * Allows you to perform aggregations operations on a Analysis.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 */
	aggregate<T extends AnalysisAggregateArgs>(
		args: Prisma.Subset<T, AnalysisAggregateArgs>,
	): Prisma.PrismaPromise<GetAnalysisAggregateType<T>>
	/**
	 * Group by Analysis.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {AnalysisGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 */
	groupBy<
		T extends AnalysisGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<'skip', Prisma.Keys<T>>,
			Prisma.Extends<'take', Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: AnalysisGroupByArgs['orderBy'] }
			: { orderBy?: AnalysisGroupByArgs['orderBy'] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T['having']>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										'Field ',
										P,
										` in "having" needs to be provided in "by"`,
									]
					}[HavingFields]
				: 'take' extends Prisma.Keys<T>
					? 'orderBy' extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: 'skip' extends Prisma.Keys<T>
						? 'orderBy' extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, AnalysisGroupByArgs, OrderByArg> &
			InputErrors,
	): {} extends InputErrors
		? GetAnalysisGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>
}

/**
 * The delegate class that acts as a "Promise-like" for Analysis.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__AnalysisClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: 'PrismaPromise'
	Preset<T extends Prisma.PresetDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.PresetDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__PresetClient<
		| runtime.Types.Result.GetResult<
				Prisma.$PresetPayload<ExtArgs>,
				T,
				'findUniqueOrThrow',
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>
	User<T extends Prisma.Analysis$UserArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Analysis$UserArgs<ExtArgs>>,
	): Prisma.Prisma__UserClient<
		runtime.Types.Result.GetResult<
			Prisma.$UserPayload<ExtArgs>,
			T,
			'findUniqueOrThrow',
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>
}

/**
 * Fields of the Analysis model
 */
export interface AnalysisFieldRefs {
	readonly originalText: Prisma.FieldRef<'Analysis', 'String'>
	readonly modifiedTextAlternatives: Prisma.FieldRef<'Analysis', 'Json'>
	readonly biasedTerms: Prisma.FieldRef<'Analysis', 'Json'>
	readonly biasedMetaphors: Prisma.FieldRef<'Analysis', 'Json'>
	readonly additionalContextEvaluation: Prisma.FieldRef<'Analysis', 'Json'>
	readonly impactAnalysis: Prisma.FieldRef<'Analysis', 'Json'>
	readonly conclusion: Prisma.FieldRef<'Analysis', 'String'>
	readonly id: Prisma.FieldRef<'Analysis', 'String'>
	readonly name: Prisma.FieldRef<'Analysis', 'String'>
	readonly visibility: Prisma.FieldRef<'Analysis', 'Visibility'>
	readonly status: Prisma.FieldRef<'Analysis', 'AnalysisStatus'>
	readonly inputSource: Prisma.FieldRef<'Analysis', 'InputSource'>
	readonly presetId: Prisma.FieldRef<'Analysis', 'String'>
	readonly userId: Prisma.FieldRef<'Analysis', 'String'>
	readonly createdAt: Prisma.FieldRef<'Analysis', 'DateTime'>
	readonly updatedAt: Prisma.FieldRef<'Analysis', 'DateTime'>
}

// Custom InputTypes
/**
 * Analysis findUnique
 */
export type AnalysisFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Analysis
	 */
	select?: Prisma.AnalysisSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Analysis
	 */
	omit?: Prisma.AnalysisOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AnalysisInclude<ExtArgs> | null
	/**
	 * Filter, which Analysis to fetch.
	 */
	where: Prisma.AnalysisWhereUniqueInput
}
/**
 * Analysis findUniqueOrThrow
 */
export type AnalysisFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Analysis
	 */
	select?: Prisma.AnalysisSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Analysis
	 */
	omit?: Prisma.AnalysisOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AnalysisInclude<ExtArgs> | null
	/**
	 * Filter, which Analysis to fetch.
	 */
	where: Prisma.AnalysisWhereUniqueInput
}
/**
 * Analysis findFirst
 */
export type AnalysisFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Analysis
	 */
	select?: Prisma.AnalysisSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Analysis
	 */
	omit?: Prisma.AnalysisOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AnalysisInclude<ExtArgs> | null
	/**
	 * Filter, which Analysis to fetch.
	 */
	where?: Prisma.AnalysisWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Analyses to fetch.
	 */
	orderBy?:
		| Prisma.AnalysisOrderByWithRelationInput
		| Prisma.AnalysisOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Analyses.
	 */
	cursor?: Prisma.AnalysisWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Analyses from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Analyses.
	 */
	skip?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Analyses.
	 */
	distinct?: Prisma.AnalysisScalarFieldEnum | Prisma.AnalysisScalarFieldEnum[]
}
/**
 * Analysis findFirstOrThrow
 */
export type AnalysisFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Analysis
	 */
	select?: Prisma.AnalysisSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Analysis
	 */
	omit?: Prisma.AnalysisOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AnalysisInclude<ExtArgs> | null
	/**
	 * Filter, which Analysis to fetch.
	 */
	where?: Prisma.AnalysisWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Analyses to fetch.
	 */
	orderBy?:
		| Prisma.AnalysisOrderByWithRelationInput
		| Prisma.AnalysisOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Analyses.
	 */
	cursor?: Prisma.AnalysisWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Analyses from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Analyses.
	 */
	skip?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Analyses.
	 */
	distinct?: Prisma.AnalysisScalarFieldEnum | Prisma.AnalysisScalarFieldEnum[]
}
/**
 * Analysis findMany
 */
export type AnalysisFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Analysis
	 */
	select?: Prisma.AnalysisSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Analysis
	 */
	omit?: Prisma.AnalysisOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AnalysisInclude<ExtArgs> | null
	/**
	 * Filter, which Analyses to fetch.
	 */
	where?: Prisma.AnalysisWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Analyses to fetch.
	 */
	orderBy?:
		| Prisma.AnalysisOrderByWithRelationInput
		| Prisma.AnalysisOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing Analyses.
	 */
	cursor?: Prisma.AnalysisWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Analyses from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Analyses.
	 */
	skip?: number
	distinct?: Prisma.AnalysisScalarFieldEnum | Prisma.AnalysisScalarFieldEnum[]
}
/**
 * Analysis create
 */
export type AnalysisCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Analysis
	 */
	select?: Prisma.AnalysisSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Analysis
	 */
	omit?: Prisma.AnalysisOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AnalysisInclude<ExtArgs> | null
	/**
	 * The data needed to create a Analysis.
	 */
	data: Prisma.XOR<
		Prisma.AnalysisCreateInput,
		Prisma.AnalysisUncheckedCreateInput
	>
}
/**
 * Analysis createMany
 */
export type AnalysisCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many Analyses.
	 */
	data: Prisma.AnalysisCreateManyInput | Prisma.AnalysisCreateManyInput[]
	skipDuplicates?: boolean
}
/**
 * Analysis createManyAndReturn
 */
export type AnalysisCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Analysis
	 */
	select?: Prisma.AnalysisSelectCreateManyAndReturn<ExtArgs> | null
	/**
	 * Omit specific fields from the Analysis
	 */
	omit?: Prisma.AnalysisOmit<ExtArgs> | null
	/**
	 * The data used to create many Analyses.
	 */
	data: Prisma.AnalysisCreateManyInput | Prisma.AnalysisCreateManyInput[]
	skipDuplicates?: boolean
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AnalysisIncludeCreateManyAndReturn<ExtArgs> | null
}
/**
 * Analysis update
 */
export type AnalysisUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Analysis
	 */
	select?: Prisma.AnalysisSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Analysis
	 */
	omit?: Prisma.AnalysisOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AnalysisInclude<ExtArgs> | null
	/**
	 * The data needed to update a Analysis.
	 */
	data: Prisma.XOR<
		Prisma.AnalysisUpdateInput,
		Prisma.AnalysisUncheckedUpdateInput
	>
	/**
	 * Choose, which Analysis to update.
	 */
	where: Prisma.AnalysisWhereUniqueInput
}
/**
 * Analysis updateMany
 */
export type AnalysisUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update Analyses.
	 */
	data: Prisma.XOR<
		Prisma.AnalysisUpdateManyMutationInput,
		Prisma.AnalysisUncheckedUpdateManyInput
	>
	/**
	 * Filter which Analyses to update
	 */
	where?: Prisma.AnalysisWhereInput
	/**
	 * Limit how many Analyses to update.
	 */
	limit?: number
}
/**
 * Analysis updateManyAndReturn
 */
export type AnalysisUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Analysis
	 */
	select?: Prisma.AnalysisSelectUpdateManyAndReturn<ExtArgs> | null
	/**
	 * Omit specific fields from the Analysis
	 */
	omit?: Prisma.AnalysisOmit<ExtArgs> | null
	/**
	 * The data used to update Analyses.
	 */
	data: Prisma.XOR<
		Prisma.AnalysisUpdateManyMutationInput,
		Prisma.AnalysisUncheckedUpdateManyInput
	>
	/**
	 * Filter which Analyses to update
	 */
	where?: Prisma.AnalysisWhereInput
	/**
	 * Limit how many Analyses to update.
	 */
	limit?: number
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AnalysisIncludeUpdateManyAndReturn<ExtArgs> | null
}
/**
 * Analysis upsert
 */
export type AnalysisUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Analysis
	 */
	select?: Prisma.AnalysisSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Analysis
	 */
	omit?: Prisma.AnalysisOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AnalysisInclude<ExtArgs> | null
	/**
	 * The filter to search for the Analysis to update in case it exists.
	 */
	where: Prisma.AnalysisWhereUniqueInput
	/**
	 * In case the Analysis found by the `where` argument doesn't exist, create a new Analysis with this data.
	 */
	create: Prisma.XOR<
		Prisma.AnalysisCreateInput,
		Prisma.AnalysisUncheckedCreateInput
	>
	/**
	 * In case the Analysis was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<
		Prisma.AnalysisUpdateInput,
		Prisma.AnalysisUncheckedUpdateInput
	>
}
/**
 * Analysis delete
 */
export type AnalysisDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Analysis
	 */
	select?: Prisma.AnalysisSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Analysis
	 */
	omit?: Prisma.AnalysisOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AnalysisInclude<ExtArgs> | null
	/**
	 * Filter which Analysis to delete.
	 */
	where: Prisma.AnalysisWhereUniqueInput
}
/**
 * Analysis deleteMany
 */
export type AnalysisDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Analyses to delete
	 */
	where?: Prisma.AnalysisWhereInput
	/**
	 * Limit how many Analyses to delete.
	 */
	limit?: number
}
/**
 * Analysis.User
 */
export type Analysis$UserArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the User
	 */
	select?: Prisma.UserSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the User
	 */
	omit?: Prisma.UserOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserInclude<ExtArgs> | null
	where?: Prisma.UserWhereInput
}
/**
 * Analysis without action
 */
export type AnalysisDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Analysis
	 */
	select?: Prisma.AnalysisSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Analysis
	 */
	omit?: Prisma.AnalysisOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AnalysisInclude<ExtArgs> | null
}
