import type { Connection, Settings } from '../../json-types'
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck
/*
 * This file exports the `Model` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/client'
import type * as $Enums from '../enums.ts'
import type * as Prisma from '../internal/prismaNamespace.ts'
/**
 * Model Model
 * @
 * @allow ('all', auth() == User)
 * @
 * @allow ('delete', auth().role == admin)
 * @
 * @allow ('read,update', isDefault)
 */
export type ModelModel =
	runtime.Types.Result.DefaultSelection<Prisma.$ModelPayload>
export type AggregateModel = {
	_count: ModelCountAggregateOutputType | null
	_min: ModelMinAggregateOutputType | null
	_max: ModelMaxAggregateOutputType | null
}
export type ModelMinAggregateOutputType = {
	id: string | null
	name: string | null
	apiKey: string | null
	status: $Enums.ModelStatus | null
	error: $Enums.ModelError | null
	userId: string | null
	createdAt: Date | null
	updatedAt: Date | null
	usedAt: Date | null
	isDefault: boolean | null
}
export type ModelMaxAggregateOutputType = {
	id: string | null
	name: string | null
	apiKey: string | null
	status: $Enums.ModelStatus | null
	error: $Enums.ModelError | null
	userId: string | null
	createdAt: Date | null
	updatedAt: Date | null
	usedAt: Date | null
	isDefault: boolean | null
}
export type ModelCountAggregateOutputType = {
	id: number
	connection: number
	settings: number
	name: number
	apiKey: number
	status: number
	error: number
	userId: number
	createdAt: number
	updatedAt: number
	usedAt: number
	isDefault: number
	_all: number
}
export type ModelMinAggregateInputType = {
	id?: true
	name?: true
	apiKey?: true
	status?: true
	error?: true
	userId?: true
	createdAt?: true
	updatedAt?: true
	usedAt?: true
	isDefault?: true
}
export type ModelMaxAggregateInputType = {
	id?: true
	name?: true
	apiKey?: true
	status?: true
	error?: true
	userId?: true
	createdAt?: true
	updatedAt?: true
	usedAt?: true
	isDefault?: true
}
export type ModelCountAggregateInputType = {
	id?: true
	connection?: true
	settings?: true
	name?: true
	apiKey?: true
	status?: true
	error?: true
	userId?: true
	createdAt?: true
	updatedAt?: true
	usedAt?: true
	isDefault?: true
	_all?: true
}
export type ModelAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Model to aggregate.
	 */
	where?: Prisma.ModelWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Models to fetch.
	 */
	orderBy?:
		| Prisma.ModelOrderByWithRelationInput
		| Prisma.ModelOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.ModelWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Models from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Models.
	 */
	skip?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned Models
	 **/
	_count?: true | ModelCountAggregateInputType
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: ModelMinAggregateInputType
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: ModelMaxAggregateInputType
}
export type GetModelAggregateType<T extends ModelAggregateArgs> = {
	[P in keyof T & keyof AggregateModel]: P extends '_count' | 'count'
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateModel[P]>
		: Prisma.GetScalarType<T[P], AggregateModel[P]>
}
export type ModelGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.ModelWhereInput
	orderBy?:
		| Prisma.ModelOrderByWithAggregationInput
		| Prisma.ModelOrderByWithAggregationInput[]
	by: Prisma.ModelScalarFieldEnum[] | Prisma.ModelScalarFieldEnum
	having?: Prisma.ModelScalarWhereWithAggregatesInput
	take?: number
	skip?: number
	_count?: ModelCountAggregateInputType | true
	_min?: ModelMinAggregateInputType
	_max?: ModelMaxAggregateInputType
}
export type ModelGroupByOutputType = {
	id: string
	connection: Connection
	settings: Settings
	name: string
	apiKey: string | null
	status: $Enums.ModelStatus
	error: $Enums.ModelError | null
	userId: string | null
	createdAt: Date
	updatedAt: Date
	usedAt: Date | null
	isDefault: boolean
	_count: ModelCountAggregateOutputType | null
	_min: ModelMinAggregateOutputType | null
	_max: ModelMaxAggregateOutputType | null
}
type GetModelGroupByPayload<T extends ModelGroupByArgs> = Prisma.PrismaPromise<
	Array<
		Prisma.PickEnumerable<ModelGroupByOutputType, T['by']> & {
			[P in keyof T & keyof ModelGroupByOutputType]: P extends '_count'
				? T[P] extends boolean
					? number
					: Prisma.GetScalarType<T[P], ModelGroupByOutputType[P]>
				: Prisma.GetScalarType<T[P], ModelGroupByOutputType[P]>
		}
	>
>
export type ModelWhereInput = {
	AND?: Prisma.ModelWhereInput | Prisma.ModelWhereInput[]
	OR?: Prisma.ModelWhereInput[]
	NOT?: Prisma.ModelWhereInput | Prisma.ModelWhereInput[]
	id?: Prisma.StringFilter<'Model'> | string
	connection?: Prisma.JsonFilter<'Model'>
	settings?: Prisma.JsonFilter<'Model'>
	name?: Prisma.StringFilter<'Model'> | string
	apiKey?: Prisma.StringNullableFilter<'Model'> | string | null
	status?: Prisma.EnumModelStatusFilter<'Model'> | $Enums.ModelStatus
	error?:
		| Prisma.EnumModelErrorNullableFilter<'Model'>
		| $Enums.ModelError
		| null
	userId?: Prisma.StringNullableFilter<'Model'> | string | null
	createdAt?: Prisma.DateTimeFilter<'Model'> | Date | string
	updatedAt?: Prisma.DateTimeFilter<'Model'> | Date | string
	usedAt?: Prisma.DateTimeNullableFilter<'Model'> | Date | string | null
	isDefault?: Prisma.BoolFilter<'Model'> | boolean
	User?: Prisma.XOR<
		Prisma.UserNullableScalarRelationFilter,
		Prisma.UserWhereInput
	> | null
	PresetModels?: Prisma.PresetModelListRelationFilter
}
export type ModelOrderByWithRelationInput = {
	id?: Prisma.SortOrder
	connection?: Prisma.SortOrder
	settings?: Prisma.SortOrder
	name?: Prisma.SortOrder
	apiKey?: Prisma.SortOrderInput | Prisma.SortOrder
	status?: Prisma.SortOrder
	error?: Prisma.SortOrderInput | Prisma.SortOrder
	userId?: Prisma.SortOrderInput | Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
	usedAt?: Prisma.SortOrderInput | Prisma.SortOrder
	isDefault?: Prisma.SortOrder
	User?: Prisma.UserOrderByWithRelationInput
	PresetModels?: Prisma.PresetModelOrderByRelationAggregateInput
	_relevance?: Prisma.ModelOrderByRelevanceInput
}
export type ModelWhereUniqueInput = Prisma.AtLeast<
	{
		id?: string
		AND?: Prisma.ModelWhereInput | Prisma.ModelWhereInput[]
		OR?: Prisma.ModelWhereInput[]
		NOT?: Prisma.ModelWhereInput | Prisma.ModelWhereInput[]
		connection?: Prisma.JsonFilter<'Model'>
		settings?: Prisma.JsonFilter<'Model'>
		name?: Prisma.StringFilter<'Model'> | string
		apiKey?: Prisma.StringNullableFilter<'Model'> | string | null
		status?: Prisma.EnumModelStatusFilter<'Model'> | $Enums.ModelStatus
		error?:
			| Prisma.EnumModelErrorNullableFilter<'Model'>
			| $Enums.ModelError
			| null
		userId?: Prisma.StringNullableFilter<'Model'> | string | null
		createdAt?: Prisma.DateTimeFilter<'Model'> | Date | string
		updatedAt?: Prisma.DateTimeFilter<'Model'> | Date | string
		usedAt?: Prisma.DateTimeNullableFilter<'Model'> | Date | string | null
		isDefault?: Prisma.BoolFilter<'Model'> | boolean
		User?: Prisma.XOR<
			Prisma.UserNullableScalarRelationFilter,
			Prisma.UserWhereInput
		> | null
		PresetModels?: Prisma.PresetModelListRelationFilter
	},
	'id'
>
export type ModelOrderByWithAggregationInput = {
	id?: Prisma.SortOrder
	connection?: Prisma.SortOrder
	settings?: Prisma.SortOrder
	name?: Prisma.SortOrder
	apiKey?: Prisma.SortOrderInput | Prisma.SortOrder
	status?: Prisma.SortOrder
	error?: Prisma.SortOrderInput | Prisma.SortOrder
	userId?: Prisma.SortOrderInput | Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
	usedAt?: Prisma.SortOrderInput | Prisma.SortOrder
	isDefault?: Prisma.SortOrder
	_count?: Prisma.ModelCountOrderByAggregateInput
	_max?: Prisma.ModelMaxOrderByAggregateInput
	_min?: Prisma.ModelMinOrderByAggregateInput
}
export type ModelScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.ModelScalarWhereWithAggregatesInput
		| Prisma.ModelScalarWhereWithAggregatesInput[]
	OR?: Prisma.ModelScalarWhereWithAggregatesInput[]
	NOT?:
		| Prisma.ModelScalarWhereWithAggregatesInput
		| Prisma.ModelScalarWhereWithAggregatesInput[]
	id?: Prisma.StringWithAggregatesFilter<'Model'> | string
	connection?: Prisma.JsonWithAggregatesFilter<'Model'>
	settings?: Prisma.JsonWithAggregatesFilter<'Model'>
	name?: Prisma.StringWithAggregatesFilter<'Model'> | string
	apiKey?: Prisma.StringNullableWithAggregatesFilter<'Model'> | string | null
	status?:
		| Prisma.EnumModelStatusWithAggregatesFilter<'Model'>
		| $Enums.ModelStatus
	error?:
		| Prisma.EnumModelErrorNullableWithAggregatesFilter<'Model'>
		| $Enums.ModelError
		| null
	userId?: Prisma.StringNullableWithAggregatesFilter<'Model'> | string | null
	createdAt?: Prisma.DateTimeWithAggregatesFilter<'Model'> | Date | string
	updatedAt?: Prisma.DateTimeWithAggregatesFilter<'Model'> | Date | string
	usedAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<'Model'>
		| Date
		| string
		| null
	isDefault?: Prisma.BoolWithAggregatesFilter<'Model'> | boolean
}
export type ModelCreateInput = {
	id?: string
	connection: Connection
	settings: Settings
	name: string
	apiKey?: string | null
	status?: $Enums.ModelStatus
	error?: $Enums.ModelError | null
	createdAt?: Date | string
	updatedAt?: Date | string
	usedAt?: Date | string | null
	isDefault?: boolean
	User?: Prisma.UserCreateNestedOneWithoutModelsInput
	PresetModels?: Prisma.PresetModelCreateNestedManyWithoutModelInput
}
export type ModelUncheckedCreateInput = {
	id?: string
	connection: Connection
	settings: Settings
	name: string
	apiKey?: string | null
	status?: $Enums.ModelStatus
	error?: $Enums.ModelError | null
	userId?: string | null
	createdAt?: Date | string
	updatedAt?: Date | string
	usedAt?: Date | string | null
	isDefault?: boolean
	PresetModels?: Prisma.PresetModelUncheckedCreateNestedManyWithoutModelInput
}
export type ModelUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string
	connection?: Connection | runtime.Types.Skip
	settings?: Settings | runtime.Types.Skip
	name?: Prisma.StringFieldUpdateOperationsInput | string
	apiKey?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	status?:
		| Prisma.EnumModelStatusFieldUpdateOperationsInput
		| $Enums.ModelStatus
	error?:
		| Prisma.NullableEnumModelErrorFieldUpdateOperationsInput
		| $Enums.ModelError
		| null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	usedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null
	isDefault?: Prisma.BoolFieldUpdateOperationsInput | boolean
	User?: Prisma.UserUpdateOneWithoutModelsNestedInput
	PresetModels?: Prisma.PresetModelUpdateManyWithoutModelNestedInput
}
export type ModelUncheckedUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string
	connection?: Connection | runtime.Types.Skip
	settings?: Settings | runtime.Types.Skip
	name?: Prisma.StringFieldUpdateOperationsInput | string
	apiKey?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	status?:
		| Prisma.EnumModelStatusFieldUpdateOperationsInput
		| $Enums.ModelStatus
	error?:
		| Prisma.NullableEnumModelErrorFieldUpdateOperationsInput
		| $Enums.ModelError
		| null
	userId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	usedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null
	isDefault?: Prisma.BoolFieldUpdateOperationsInput | boolean
	PresetModels?: Prisma.PresetModelUncheckedUpdateManyWithoutModelNestedInput
}
export type ModelCreateManyInput = {
	id?: string
	connection: Connection
	settings: Settings
	name: string
	apiKey?: string | null
	status?: $Enums.ModelStatus
	error?: $Enums.ModelError | null
	userId?: string | null
	createdAt?: Date | string
	updatedAt?: Date | string
	usedAt?: Date | string | null
	isDefault?: boolean
}
export type ModelUpdateManyMutationInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string
	connection?: Connection | runtime.Types.Skip
	settings?: Settings | runtime.Types.Skip
	name?: Prisma.StringFieldUpdateOperationsInput | string
	apiKey?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	status?:
		| Prisma.EnumModelStatusFieldUpdateOperationsInput
		| $Enums.ModelStatus
	error?:
		| Prisma.NullableEnumModelErrorFieldUpdateOperationsInput
		| $Enums.ModelError
		| null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	usedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null
	isDefault?: Prisma.BoolFieldUpdateOperationsInput | boolean
}
export type ModelUncheckedUpdateManyInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string
	connection?: Connection | runtime.Types.Skip
	settings?: Settings | runtime.Types.Skip
	name?: Prisma.StringFieldUpdateOperationsInput | string
	apiKey?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	status?:
		| Prisma.EnumModelStatusFieldUpdateOperationsInput
		| $Enums.ModelStatus
	error?:
		| Prisma.NullableEnumModelErrorFieldUpdateOperationsInput
		| $Enums.ModelError
		| null
	userId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	usedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null
	isDefault?: Prisma.BoolFieldUpdateOperationsInput | boolean
}
export type ModelListRelationFilter = {
	every?: Prisma.ModelWhereInput
	some?: Prisma.ModelWhereInput
	none?: Prisma.ModelWhereInput
}
export type ModelOrderByRelationAggregateInput = { _count?: Prisma.SortOrder }
export type ModelScalarRelationFilter = {
	is?: Prisma.ModelWhereInput
	isNot?: Prisma.ModelWhereInput
}
export type ModelOrderByRelevanceInput = {
	fields:
		| Prisma.ModelOrderByRelevanceFieldEnum
		| Prisma.ModelOrderByRelevanceFieldEnum[]
	sort: Prisma.SortOrder
	search: string
}
export type ModelCountOrderByAggregateInput = {
	id?: Prisma.SortOrder
	connection?: Prisma.SortOrder
	settings?: Prisma.SortOrder
	name?: Prisma.SortOrder
	apiKey?: Prisma.SortOrder
	status?: Prisma.SortOrder
	error?: Prisma.SortOrder
	userId?: Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
	usedAt?: Prisma.SortOrder
	isDefault?: Prisma.SortOrder
}
export type ModelMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder
	name?: Prisma.SortOrder
	apiKey?: Prisma.SortOrder
	status?: Prisma.SortOrder
	error?: Prisma.SortOrder
	userId?: Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
	usedAt?: Prisma.SortOrder
	isDefault?: Prisma.SortOrder
}
export type ModelMinOrderByAggregateInput = {
	id?: Prisma.SortOrder
	name?: Prisma.SortOrder
	apiKey?: Prisma.SortOrder
	status?: Prisma.SortOrder
	error?: Prisma.SortOrder
	userId?: Prisma.SortOrder
	createdAt?: Prisma.SortOrder
	updatedAt?: Prisma.SortOrder
	usedAt?: Prisma.SortOrder
	isDefault?: Prisma.SortOrder
}
export type ModelCreateNestedManyWithoutUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.ModelCreateWithoutUserInput,
				Prisma.ModelUncheckedCreateWithoutUserInput
		  >
		| Prisma.ModelCreateWithoutUserInput[]
		| Prisma.ModelUncheckedCreateWithoutUserInput[]
	connectOrCreate?:
		| Prisma.ModelCreateOrConnectWithoutUserInput
		| Prisma.ModelCreateOrConnectWithoutUserInput[]
	createMany?: Prisma.ModelCreateManyUserInputEnvelope
	connect?: Prisma.ModelWhereUniqueInput | Prisma.ModelWhereUniqueInput[]
}
export type ModelUncheckedCreateNestedManyWithoutUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.ModelCreateWithoutUserInput,
				Prisma.ModelUncheckedCreateWithoutUserInput
		  >
		| Prisma.ModelCreateWithoutUserInput[]
		| Prisma.ModelUncheckedCreateWithoutUserInput[]
	connectOrCreate?:
		| Prisma.ModelCreateOrConnectWithoutUserInput
		| Prisma.ModelCreateOrConnectWithoutUserInput[]
	createMany?: Prisma.ModelCreateManyUserInputEnvelope
	connect?: Prisma.ModelWhereUniqueInput | Prisma.ModelWhereUniqueInput[]
}
export type ModelUpdateManyWithoutUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.ModelCreateWithoutUserInput,
				Prisma.ModelUncheckedCreateWithoutUserInput
		  >
		| Prisma.ModelCreateWithoutUserInput[]
		| Prisma.ModelUncheckedCreateWithoutUserInput[]
	connectOrCreate?:
		| Prisma.ModelCreateOrConnectWithoutUserInput
		| Prisma.ModelCreateOrConnectWithoutUserInput[]
	upsert?:
		| Prisma.ModelUpsertWithWhereUniqueWithoutUserInput
		| Prisma.ModelUpsertWithWhereUniqueWithoutUserInput[]
	createMany?: Prisma.ModelCreateManyUserInputEnvelope
	set?: Prisma.ModelWhereUniqueInput | Prisma.ModelWhereUniqueInput[]
	disconnect?: Prisma.ModelWhereUniqueInput | Prisma.ModelWhereUniqueInput[]
	delete?: Prisma.ModelWhereUniqueInput | Prisma.ModelWhereUniqueInput[]
	connect?: Prisma.ModelWhereUniqueInput | Prisma.ModelWhereUniqueInput[]
	update?:
		| Prisma.ModelUpdateWithWhereUniqueWithoutUserInput
		| Prisma.ModelUpdateWithWhereUniqueWithoutUserInput[]
	updateMany?:
		| Prisma.ModelUpdateManyWithWhereWithoutUserInput
		| Prisma.ModelUpdateManyWithWhereWithoutUserInput[]
	deleteMany?: Prisma.ModelScalarWhereInput | Prisma.ModelScalarWhereInput[]
}
export type ModelUncheckedUpdateManyWithoutUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.ModelCreateWithoutUserInput,
				Prisma.ModelUncheckedCreateWithoutUserInput
		  >
		| Prisma.ModelCreateWithoutUserInput[]
		| Prisma.ModelUncheckedCreateWithoutUserInput[]
	connectOrCreate?:
		| Prisma.ModelCreateOrConnectWithoutUserInput
		| Prisma.ModelCreateOrConnectWithoutUserInput[]
	upsert?:
		| Prisma.ModelUpsertWithWhereUniqueWithoutUserInput
		| Prisma.ModelUpsertWithWhereUniqueWithoutUserInput[]
	createMany?: Prisma.ModelCreateManyUserInputEnvelope
	set?: Prisma.ModelWhereUniqueInput | Prisma.ModelWhereUniqueInput[]
	disconnect?: Prisma.ModelWhereUniqueInput | Prisma.ModelWhereUniqueInput[]
	delete?: Prisma.ModelWhereUniqueInput | Prisma.ModelWhereUniqueInput[]
	connect?: Prisma.ModelWhereUniqueInput | Prisma.ModelWhereUniqueInput[]
	update?:
		| Prisma.ModelUpdateWithWhereUniqueWithoutUserInput
		| Prisma.ModelUpdateWithWhereUniqueWithoutUserInput[]
	updateMany?:
		| Prisma.ModelUpdateManyWithWhereWithoutUserInput
		| Prisma.ModelUpdateManyWithWhereWithoutUserInput[]
	deleteMany?: Prisma.ModelScalarWhereInput | Prisma.ModelScalarWhereInput[]
}
export type ModelCreateNestedOneWithoutPresetModelsInput = {
	create?: Prisma.XOR<
		Prisma.ModelCreateWithoutPresetModelsInput,
		Prisma.ModelUncheckedCreateWithoutPresetModelsInput
	>
	connectOrCreate?: Prisma.ModelCreateOrConnectWithoutPresetModelsInput
	connect?: Prisma.ModelWhereUniqueInput
}
export type ModelUpdateOneRequiredWithoutPresetModelsNestedInput = {
	create?: Prisma.XOR<
		Prisma.ModelCreateWithoutPresetModelsInput,
		Prisma.ModelUncheckedCreateWithoutPresetModelsInput
	>
	connectOrCreate?: Prisma.ModelCreateOrConnectWithoutPresetModelsInput
	upsert?: Prisma.ModelUpsertWithoutPresetModelsInput
	connect?: Prisma.ModelWhereUniqueInput
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.ModelUpdateToOneWithWhereWithoutPresetModelsInput,
			Prisma.ModelUpdateWithoutPresetModelsInput
		>,
		Prisma.ModelUncheckedUpdateWithoutPresetModelsInput
	>
}
export type EnumModelStatusFieldUpdateOperationsInput = {
	set?: $Enums.ModelStatus
}
export type NullableEnumModelErrorFieldUpdateOperationsInput = {
	set?: $Enums.ModelError | null
}
export type ModelCreateWithoutUserInput = {
	id?: string
	connection: Connection
	settings: Settings
	name: string
	apiKey?: string | null
	status?: $Enums.ModelStatus
	error?: $Enums.ModelError | null
	createdAt?: Date | string
	updatedAt?: Date | string
	usedAt?: Date | string | null
	isDefault?: boolean
	PresetModels?: Prisma.PresetModelCreateNestedManyWithoutModelInput
}
export type ModelUncheckedCreateWithoutUserInput = {
	id?: string
	connection: Connection
	settings: Settings
	name: string
	apiKey?: string | null
	status?: $Enums.ModelStatus
	error?: $Enums.ModelError | null
	createdAt?: Date | string
	updatedAt?: Date | string
	usedAt?: Date | string | null
	isDefault?: boolean
	PresetModels?: Prisma.PresetModelUncheckedCreateNestedManyWithoutModelInput
}
export type ModelCreateOrConnectWithoutUserInput = {
	where: Prisma.ModelWhereUniqueInput
	create: Prisma.XOR<
		Prisma.ModelCreateWithoutUserInput,
		Prisma.ModelUncheckedCreateWithoutUserInput
	>
}
export type ModelCreateManyUserInputEnvelope = {
	data: Prisma.ModelCreateManyUserInput | Prisma.ModelCreateManyUserInput[]
	skipDuplicates?: boolean
}
export type ModelUpsertWithWhereUniqueWithoutUserInput = {
	where: Prisma.ModelWhereUniqueInput
	update: Prisma.XOR<
		Prisma.ModelUpdateWithoutUserInput,
		Prisma.ModelUncheckedUpdateWithoutUserInput
	>
	create: Prisma.XOR<
		Prisma.ModelCreateWithoutUserInput,
		Prisma.ModelUncheckedCreateWithoutUserInput
	>
}
export type ModelUpdateWithWhereUniqueWithoutUserInput = {
	where: Prisma.ModelWhereUniqueInput
	data: Prisma.XOR<
		Prisma.ModelUpdateWithoutUserInput,
		Prisma.ModelUncheckedUpdateWithoutUserInput
	>
}
export type ModelUpdateManyWithWhereWithoutUserInput = {
	where: Prisma.ModelScalarWhereInput
	data: Prisma.XOR<
		Prisma.ModelUpdateManyMutationInput,
		Prisma.ModelUncheckedUpdateManyWithoutUserInput
	>
}
export type ModelScalarWhereInput = {
	AND?: Prisma.ModelScalarWhereInput | Prisma.ModelScalarWhereInput[]
	OR?: Prisma.ModelScalarWhereInput[]
	NOT?: Prisma.ModelScalarWhereInput | Prisma.ModelScalarWhereInput[]
	id?: Prisma.StringFilter<'Model'> | string
	connection?: Prisma.JsonFilter<'Model'>
	settings?: Prisma.JsonFilter<'Model'>
	name?: Prisma.StringFilter<'Model'> | string
	apiKey?: Prisma.StringNullableFilter<'Model'> | string | null
	status?: Prisma.EnumModelStatusFilter<'Model'> | $Enums.ModelStatus
	error?:
		| Prisma.EnumModelErrorNullableFilter<'Model'>
		| $Enums.ModelError
		| null
	userId?: Prisma.StringNullableFilter<'Model'> | string | null
	createdAt?: Prisma.DateTimeFilter<'Model'> | Date | string
	updatedAt?: Prisma.DateTimeFilter<'Model'> | Date | string
	usedAt?: Prisma.DateTimeNullableFilter<'Model'> | Date | string | null
	isDefault?: Prisma.BoolFilter<'Model'> | boolean
}
export type ModelCreateWithoutPresetModelsInput = {
	id?: string
	connection: Connection
	settings: Settings
	name: string
	apiKey?: string | null
	status?: $Enums.ModelStatus
	error?: $Enums.ModelError | null
	createdAt?: Date | string
	updatedAt?: Date | string
	usedAt?: Date | string | null
	isDefault?: boolean
	User?: Prisma.UserCreateNestedOneWithoutModelsInput
}
export type ModelUncheckedCreateWithoutPresetModelsInput = {
	id?: string
	connection: Connection
	settings: Settings
	name: string
	apiKey?: string | null
	status?: $Enums.ModelStatus
	error?: $Enums.ModelError | null
	userId?: string | null
	createdAt?: Date | string
	updatedAt?: Date | string
	usedAt?: Date | string | null
	isDefault?: boolean
}
export type ModelCreateOrConnectWithoutPresetModelsInput = {
	where: Prisma.ModelWhereUniqueInput
	create: Prisma.XOR<
		Prisma.ModelCreateWithoutPresetModelsInput,
		Prisma.ModelUncheckedCreateWithoutPresetModelsInput
	>
}
export type ModelUpsertWithoutPresetModelsInput = {
	update: Prisma.XOR<
		Prisma.ModelUpdateWithoutPresetModelsInput,
		Prisma.ModelUncheckedUpdateWithoutPresetModelsInput
	>
	create: Prisma.XOR<
		Prisma.ModelCreateWithoutPresetModelsInput,
		Prisma.ModelUncheckedCreateWithoutPresetModelsInput
	>
	where?: Prisma.ModelWhereInput
}
export type ModelUpdateToOneWithWhereWithoutPresetModelsInput = {
	where?: Prisma.ModelWhereInput
	data: Prisma.XOR<
		Prisma.ModelUpdateWithoutPresetModelsInput,
		Prisma.ModelUncheckedUpdateWithoutPresetModelsInput
	>
}
export type ModelUpdateWithoutPresetModelsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string
	connection?: Connection | runtime.Types.Skip
	settings?: Settings | runtime.Types.Skip
	name?: Prisma.StringFieldUpdateOperationsInput | string
	apiKey?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	status?:
		| Prisma.EnumModelStatusFieldUpdateOperationsInput
		| $Enums.ModelStatus
	error?:
		| Prisma.NullableEnumModelErrorFieldUpdateOperationsInput
		| $Enums.ModelError
		| null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	usedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null
	isDefault?: Prisma.BoolFieldUpdateOperationsInput | boolean
	User?: Prisma.UserUpdateOneWithoutModelsNestedInput
}
export type ModelUncheckedUpdateWithoutPresetModelsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string
	connection?: Connection | runtime.Types.Skip
	settings?: Settings | runtime.Types.Skip
	name?: Prisma.StringFieldUpdateOperationsInput | string
	apiKey?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	status?:
		| Prisma.EnumModelStatusFieldUpdateOperationsInput
		| $Enums.ModelStatus
	error?:
		| Prisma.NullableEnumModelErrorFieldUpdateOperationsInput
		| $Enums.ModelError
		| null
	userId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	usedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null
	isDefault?: Prisma.BoolFieldUpdateOperationsInput | boolean
}
export type ModelCreateManyUserInput = {
	id?: string
	connection: Connection
	settings: Settings
	name: string
	apiKey?: string | null
	status?: $Enums.ModelStatus
	error?: $Enums.ModelError | null
	createdAt?: Date | string
	updatedAt?: Date | string
	usedAt?: Date | string | null
	isDefault?: boolean
}
export type ModelUpdateWithoutUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string
	connection?: Connection | runtime.Types.Skip
	settings?: Settings | runtime.Types.Skip
	name?: Prisma.StringFieldUpdateOperationsInput | string
	apiKey?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	status?:
		| Prisma.EnumModelStatusFieldUpdateOperationsInput
		| $Enums.ModelStatus
	error?:
		| Prisma.NullableEnumModelErrorFieldUpdateOperationsInput
		| $Enums.ModelError
		| null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	usedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null
	isDefault?: Prisma.BoolFieldUpdateOperationsInput | boolean
	PresetModels?: Prisma.PresetModelUpdateManyWithoutModelNestedInput
}
export type ModelUncheckedUpdateWithoutUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string
	connection?: Connection | runtime.Types.Skip
	settings?: Settings | runtime.Types.Skip
	name?: Prisma.StringFieldUpdateOperationsInput | string
	apiKey?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	status?:
		| Prisma.EnumModelStatusFieldUpdateOperationsInput
		| $Enums.ModelStatus
	error?:
		| Prisma.NullableEnumModelErrorFieldUpdateOperationsInput
		| $Enums.ModelError
		| null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	usedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null
	isDefault?: Prisma.BoolFieldUpdateOperationsInput | boolean
	PresetModels?: Prisma.PresetModelUncheckedUpdateManyWithoutModelNestedInput
}
export type ModelUncheckedUpdateManyWithoutUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string
	connection?: Connection | runtime.Types.Skip
	settings?: Settings | runtime.Types.Skip
	name?: Prisma.StringFieldUpdateOperationsInput | string
	apiKey?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
	status?:
		| Prisma.EnumModelStatusFieldUpdateOperationsInput
		| $Enums.ModelStatus
	error?:
		| Prisma.NullableEnumModelErrorFieldUpdateOperationsInput
		| $Enums.ModelError
		| null
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
	usedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null
	isDefault?: Prisma.BoolFieldUpdateOperationsInput | boolean
}
/**
 * Count Type ModelCountOutputType
 */
export type ModelCountOutputType = { PresetModels: number }
export type ModelCountOutputTypeSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = { PresetModels?: boolean | ModelCountOutputTypeCountPresetModelsArgs }
/**
 * ModelCountOutputType without action
 */
export type ModelCountOutputTypeDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the ModelCountOutputType
	 */
	select?: Prisma.ModelCountOutputTypeSelect<ExtArgs> | null
}
/**
 * ModelCountOutputType without action
 */
export type ModelCountOutputTypeCountPresetModelsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = { where?: Prisma.PresetModelWhereInput }
export type ModelSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean
		connection?: boolean
		settings?: boolean
		name?: boolean
		apiKey?: boolean
		status?: boolean
		error?: boolean
		userId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		usedAt?: boolean
		isDefault?: boolean
		User?: boolean | Prisma.Model$UserArgs<ExtArgs>
		PresetModels?: boolean | Prisma.Model$PresetModelsArgs<ExtArgs>
		_count?: boolean | Prisma.ModelCountOutputTypeDefaultArgs<ExtArgs>
	},
	ExtArgs['result']['model']
>
export type ModelSelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean
		connection?: boolean
		settings?: boolean
		name?: boolean
		apiKey?: boolean
		status?: boolean
		error?: boolean
		userId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		usedAt?: boolean
		isDefault?: boolean
		User?: boolean | Prisma.Model$UserArgs<ExtArgs>
	},
	ExtArgs['result']['model']
>
export type ModelSelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean
		connection?: boolean
		settings?: boolean
		name?: boolean
		apiKey?: boolean
		status?: boolean
		error?: boolean
		userId?: boolean
		createdAt?: boolean
		updatedAt?: boolean
		usedAt?: boolean
		isDefault?: boolean
		User?: boolean | Prisma.Model$UserArgs<ExtArgs>
	},
	ExtArgs['result']['model']
>
export type ModelSelectScalar = {
	id?: boolean
	connection?: boolean
	settings?: boolean
	name?: boolean
	apiKey?: boolean
	status?: boolean
	error?: boolean
	userId?: boolean
	createdAt?: boolean
	updatedAt?: boolean
	usedAt?: boolean
	isDefault?: boolean
}
export type ModelOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	| 'id'
	| 'connection'
	| 'settings'
	| 'name'
	| 'apiKey'
	| 'status'
	| 'error'
	| 'userId'
	| 'createdAt'
	| 'updatedAt'
	| 'usedAt'
	| 'isDefault',
	ExtArgs['result']['model']
>
export type ModelInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	User?: boolean | Prisma.Model$UserArgs<ExtArgs>
	PresetModels?: boolean | Prisma.Model$PresetModelsArgs<ExtArgs>
	_count?: boolean | Prisma.ModelCountOutputTypeDefaultArgs<ExtArgs>
}
export type ModelIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = { User?: boolean | Prisma.Model$UserArgs<ExtArgs> }
export type ModelIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = { User?: boolean | Prisma.Model$UserArgs<ExtArgs> }
export type $ModelPayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: 'Model'
	objects: {
		User: Prisma.$UserPayload<ExtArgs> | null
		PresetModels: Prisma.$PresetModelPayload<ExtArgs>[]
	}
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: string
			/**
			 * @json
			 */
			connection: Connection
			/**
			 * @json
			 */
			settings: Settings
			name: string
			/**
			 * @encrypted
			 */
			apiKey: string | null
			status: $Enums.ModelStatus
			error: $Enums.ModelError | null
			userId: string | null
			createdAt: Date
			updatedAt: Date
			usedAt: Date | null
			isDefault: boolean
		},
		ExtArgs['result']['model']
	>
	composites: {}
}
export type ModelGetPayload<
	S extends boolean | null | undefined | ModelDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$ModelPayload, S>
export type ModelCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<ModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
	select?: ModelCountAggregateInputType | true
}

export interface ModelDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>['model']['Model']
		meta: { name: 'Model' }
	}
	/**
	 * Fields of the Model model
	 */
	readonly fields: ModelFieldRefs
	/**
	 * Find zero or one Model that matches the filter.
	 * @param {ModelFindUniqueArgs} args - Arguments to find a Model
	 * @example
	 * // Get one Model
	 * const model = await prisma.model.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends ModelFindUniqueArgs>(
		args: Prisma.SelectSubset<T, ModelFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__ModelClient<
		runtime.Types.Result.GetResult<
			Prisma.$ModelPayload<ExtArgs>,
			T,
			'findUnique',
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Find one Model that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {ModelFindUniqueOrThrowArgs} args - Arguments to find a Model
	 * @example
	 * // Get one Model
	 * const model = await prisma.model.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends ModelFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, ModelFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__ModelClient<
		runtime.Types.Result.GetResult<
			Prisma.$ModelPayload<ExtArgs>,
			T,
			'findUniqueOrThrow',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Find the first Model that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ModelFindFirstArgs} args - Arguments to find a Model
	 * @example
	 * // Get one Model
	 * const model = await prisma.model.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends ModelFindFirstArgs>(
		args?: Prisma.SelectSubset<T, ModelFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__ModelClient<
		runtime.Types.Result.GetResult<
			Prisma.$ModelPayload<ExtArgs>,
			T,
			'findFirst',
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Find the first Model that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ModelFindFirstOrThrowArgs} args - Arguments to find a Model
	 * @example
	 * // Get one Model
	 * const model = await prisma.model.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends ModelFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, ModelFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__ModelClient<
		runtime.Types.Result.GetResult<
			Prisma.$ModelPayload<ExtArgs>,
			T,
			'findFirstOrThrow',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Find zero or more Models that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ModelFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all Models
	 * const models = await prisma.model.findMany()
	 *
	 * // Get first 10 Models
	 * const models = await prisma.model.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const modelWithIdOnly = await prisma.model.findMany({ select: { id: true } })
	 */
	findMany<T extends ModelFindManyArgs>(
		args?: Prisma.SelectSubset<T, ModelFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$ModelPayload<ExtArgs>,
			T,
			'findMany',
			GlobalOmitOptions
		>
	>
	/**
	 * Create a Model.
	 * @param {ModelCreateArgs} args - Arguments to create a Model.
	 * @example
	 * // Create one Model
	 * const Model = await prisma.model.create({
	 *   data: {
	 *     // ... data to create a Model
	 *   }
	 * })
	 */
	create<T extends ModelCreateArgs>(
		args: Prisma.SelectSubset<T, ModelCreateArgs<ExtArgs>>,
	): Prisma.Prisma__ModelClient<
		runtime.Types.Result.GetResult<
			Prisma.$ModelPayload<ExtArgs>,
			T,
			'create',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Create many Models.
	 * @param {ModelCreateManyArgs} args - Arguments to create many Models.
	 * @example
	 * // Create many Models
	 * const model = await prisma.model.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 */
	createMany<T extends ModelCreateManyArgs>(
		args?: Prisma.SelectSubset<T, ModelCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>
	/**
	 * Create many Models and returns the data saved in the database.
	 * @param {ModelCreateManyAndReturnArgs} args - Arguments to create many Models.
	 * @example
	 * // Create many Models
	 * const model = await prisma.model.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many Models and only return the `id`
	 * const modelWithIdOnly = await prisma.model.createManyAndReturn({
	 *   select: { id: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 */
	createManyAndReturn<T extends ModelCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<T, ModelCreateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$ModelPayload<ExtArgs>,
			T,
			'createManyAndReturn',
			GlobalOmitOptions
		>
	>
	/**
	 * Delete a Model.
	 * @param {ModelDeleteArgs} args - Arguments to delete one Model.
	 * @example
	 * // Delete one Model
	 * const Model = await prisma.model.delete({
	 *   where: {
	 *     // ... filter to delete one Model
	 *   }
	 * })
	 */
	delete<T extends ModelDeleteArgs>(
		args: Prisma.SelectSubset<T, ModelDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__ModelClient<
		runtime.Types.Result.GetResult<
			Prisma.$ModelPayload<ExtArgs>,
			T,
			'delete',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Update one Model.
	 * @param {ModelUpdateArgs} args - Arguments to update one Model.
	 * @example
	 * // Update one Model
	 * const model = await prisma.model.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 */
	update<T extends ModelUpdateArgs>(
		args: Prisma.SelectSubset<T, ModelUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__ModelClient<
		runtime.Types.Result.GetResult<
			Prisma.$ModelPayload<ExtArgs>,
			T,
			'update',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Delete zero or more Models.
	 * @param {ModelDeleteManyArgs} args - Arguments to filter Models to delete.
	 * @example
	 * // Delete a few Models
	 * const { count } = await prisma.model.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	deleteMany<T extends ModelDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, ModelDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>
	/**
	 * Update zero or more Models.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ModelUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many Models
	 * const model = await prisma.model.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 */
	updateMany<T extends ModelUpdateManyArgs>(
		args: Prisma.SelectSubset<T, ModelUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>
	/**
	 * Update zero or more Models and returns the data updated in the database.
	 * @param {ModelUpdateManyAndReturnArgs} args - Arguments to update many Models.
	 * @example
	 * // Update many Models
	 * const model = await prisma.model.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more Models and only return the `id`
	 * const modelWithIdOnly = await prisma.model.updateManyAndReturn({
	 *   select: { id: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 */
	updateManyAndReturn<T extends ModelUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<T, ModelUpdateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$ModelPayload<ExtArgs>,
			T,
			'updateManyAndReturn',
			GlobalOmitOptions
		>
	>
	/**
	 * Create or update one Model.
	 * @param {ModelUpsertArgs} args - Arguments to update or create a Model.
	 * @example
	 * // Update or create a Model
	 * const model = await prisma.model.upsert({
	 *   create: {
	 *     // ... data to create a Model
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the Model we want to update
	 *   }
	 * })
	 */
	upsert<T extends ModelUpsertArgs>(
		args: Prisma.SelectSubset<T, ModelUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__ModelClient<
		runtime.Types.Result.GetResult<
			Prisma.$ModelPayload<ExtArgs>,
			T,
			'upsert',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>
	/**
	 * Count the number of Models.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ModelCountArgs} args - Arguments to filter Models to count.
	 * @example
	 * // Count the number of Models
	 * const count = await prisma.model.count({
	 *   where: {
	 *     // ... the filter for the Models we want to count
	 *   }
	 * })
	 */
	count<T extends ModelCountArgs>(
		args?: Prisma.Subset<T, ModelCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<'select', any>
			? T['select'] extends true
				? number
				: Prisma.GetScalarType<
						T['select'],
						ModelCountAggregateOutputType
					>
			: number
	>
	/**
	 * Allows you to perform aggregations operations on a Model.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 */
	aggregate<T extends ModelAggregateArgs>(
		args: Prisma.Subset<T, ModelAggregateArgs>,
	): Prisma.PrismaPromise<GetModelAggregateType<T>>
	/**
	 * Group by Model.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {ModelGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 */
	groupBy<
		T extends ModelGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<'skip', Prisma.Keys<T>>,
			Prisma.Extends<'take', Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: ModelGroupByArgs['orderBy'] }
			: { orderBy?: ModelGroupByArgs['orderBy'] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T['having']>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										'Field ',
										P,
										` in "having" needs to be provided in "by"`,
									]
					}[HavingFields]
				: 'take' extends Prisma.Keys<T>
					? 'orderBy' extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: 'skip' extends Prisma.Keys<T>
						? 'orderBy' extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, ModelGroupByArgs, OrderByArg> &
			InputErrors,
	): {} extends InputErrors
		? GetModelGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>
}

/**
 * The delegate class that acts as a "Promise-like" for Model.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ModelClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: 'PrismaPromise'
	User<T extends Prisma.Model$UserArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Model$UserArgs<ExtArgs>>,
	): Prisma.Prisma__UserClient<
		runtime.Types.Result.GetResult<
			Prisma.$UserPayload<ExtArgs>,
			T,
			'findUniqueOrThrow',
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>
	PresetModels<T extends Prisma.Model$PresetModelsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Model$PresetModelsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$PresetModelPayload<ExtArgs>,
				T,
				'findMany',
				GlobalOmitOptions
		  >
		| Null
	>
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>
}

/**
 * Fields of the Model model
 */
export interface ModelFieldRefs {
	readonly id: Prisma.FieldRef<'Model', 'String'>
	readonly connection: Prisma.FieldRef<'Model', 'Json'>
	readonly settings: Prisma.FieldRef<'Model', 'Json'>
	readonly name: Prisma.FieldRef<'Model', 'String'>
	readonly apiKey: Prisma.FieldRef<'Model', 'String'>
	readonly status: Prisma.FieldRef<'Model', 'ModelStatus'>
	readonly error: Prisma.FieldRef<'Model', 'ModelError'>
	readonly userId: Prisma.FieldRef<'Model', 'String'>
	readonly createdAt: Prisma.FieldRef<'Model', 'DateTime'>
	readonly updatedAt: Prisma.FieldRef<'Model', 'DateTime'>
	readonly usedAt: Prisma.FieldRef<'Model', 'DateTime'>
	readonly isDefault: Prisma.FieldRef<'Model', 'Boolean'>
}

// Custom InputTypes
/**
 * Model findUnique
 */
export type ModelFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Model
	 */
	select?: Prisma.ModelSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Model
	 */
	omit?: Prisma.ModelOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ModelInclude<ExtArgs> | null
	/**
	 * Filter, which Model to fetch.
	 */
	where: Prisma.ModelWhereUniqueInput
}
/**
 * Model findUniqueOrThrow
 */
export type ModelFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Model
	 */
	select?: Prisma.ModelSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Model
	 */
	omit?: Prisma.ModelOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ModelInclude<ExtArgs> | null
	/**
	 * Filter, which Model to fetch.
	 */
	where: Prisma.ModelWhereUniqueInput
}
/**
 * Model findFirst
 */
export type ModelFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Model
	 */
	select?: Prisma.ModelSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Model
	 */
	omit?: Prisma.ModelOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ModelInclude<ExtArgs> | null
	/**
	 * Filter, which Model to fetch.
	 */
	where?: Prisma.ModelWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Models to fetch.
	 */
	orderBy?:
		| Prisma.ModelOrderByWithRelationInput
		| Prisma.ModelOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Models.
	 */
	cursor?: Prisma.ModelWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Models from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Models.
	 */
	skip?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Models.
	 */
	distinct?: Prisma.ModelScalarFieldEnum | Prisma.ModelScalarFieldEnum[]
}
/**
 * Model findFirstOrThrow
 */
export type ModelFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Model
	 */
	select?: Prisma.ModelSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Model
	 */
	omit?: Prisma.ModelOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ModelInclude<ExtArgs> | null
	/**
	 * Filter, which Model to fetch.
	 */
	where?: Prisma.ModelWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Models to fetch.
	 */
	orderBy?:
		| Prisma.ModelOrderByWithRelationInput
		| Prisma.ModelOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Models.
	 */
	cursor?: Prisma.ModelWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Models from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Models.
	 */
	skip?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Models.
	 */
	distinct?: Prisma.ModelScalarFieldEnum | Prisma.ModelScalarFieldEnum[]
}
/**
 * Model findMany
 */
export type ModelFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Model
	 */
	select?: Prisma.ModelSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Model
	 */
	omit?: Prisma.ModelOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ModelInclude<ExtArgs> | null
	/**
	 * Filter, which Models to fetch.
	 */
	where?: Prisma.ModelWhereInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Models to fetch.
	 */
	orderBy?:
		| Prisma.ModelOrderByWithRelationInput
		| Prisma.ModelOrderByWithRelationInput[]
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing Models.
	 */
	cursor?: Prisma.ModelWhereUniqueInput
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Models from the position of the cursor.
	 */
	take?: number
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Models.
	 */
	skip?: number
	distinct?: Prisma.ModelScalarFieldEnum | Prisma.ModelScalarFieldEnum[]
}
/**
 * Model create
 */
export type ModelCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Model
	 */
	select?: Prisma.ModelSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Model
	 */
	omit?: Prisma.ModelOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ModelInclude<ExtArgs> | null
	/**
	 * The data needed to create a Model.
	 */
	data: Prisma.XOR<Prisma.ModelCreateInput, Prisma.ModelUncheckedCreateInput>
}
/**
 * Model createMany
 */
export type ModelCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many Models.
	 */
	data: Prisma.ModelCreateManyInput | Prisma.ModelCreateManyInput[]
	skipDuplicates?: boolean
}
/**
 * Model createManyAndReturn
 */
export type ModelCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Model
	 */
	select?: Prisma.ModelSelectCreateManyAndReturn<ExtArgs> | null
	/**
	 * Omit specific fields from the Model
	 */
	omit?: Prisma.ModelOmit<ExtArgs> | null
	/**
	 * The data used to create many Models.
	 */
	data: Prisma.ModelCreateManyInput | Prisma.ModelCreateManyInput[]
	skipDuplicates?: boolean
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ModelIncludeCreateManyAndReturn<ExtArgs> | null
}
/**
 * Model update
 */
export type ModelUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Model
	 */
	select?: Prisma.ModelSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Model
	 */
	omit?: Prisma.ModelOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ModelInclude<ExtArgs> | null
	/**
	 * The data needed to update a Model.
	 */
	data: Prisma.XOR<Prisma.ModelUpdateInput, Prisma.ModelUncheckedUpdateInput>
	/**
	 * Choose, which Model to update.
	 */
	where: Prisma.ModelWhereUniqueInput
}
/**
 * Model updateMany
 */
export type ModelUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update Models.
	 */
	data: Prisma.XOR<
		Prisma.ModelUpdateManyMutationInput,
		Prisma.ModelUncheckedUpdateManyInput
	>
	/**
	 * Filter which Models to update
	 */
	where?: Prisma.ModelWhereInput
	/**
	 * Limit how many Models to update.
	 */
	limit?: number
}
/**
 * Model updateManyAndReturn
 */
export type ModelUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Model
	 */
	select?: Prisma.ModelSelectUpdateManyAndReturn<ExtArgs> | null
	/**
	 * Omit specific fields from the Model
	 */
	omit?: Prisma.ModelOmit<ExtArgs> | null
	/**
	 * The data used to update Models.
	 */
	data: Prisma.XOR<
		Prisma.ModelUpdateManyMutationInput,
		Prisma.ModelUncheckedUpdateManyInput
	>
	/**
	 * Filter which Models to update
	 */
	where?: Prisma.ModelWhereInput
	/**
	 * Limit how many Models to update.
	 */
	limit?: number
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ModelIncludeUpdateManyAndReturn<ExtArgs> | null
}
/**
 * Model upsert
 */
export type ModelUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Model
	 */
	select?: Prisma.ModelSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Model
	 */
	omit?: Prisma.ModelOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ModelInclude<ExtArgs> | null
	/**
	 * The filter to search for the Model to update in case it exists.
	 */
	where: Prisma.ModelWhereUniqueInput
	/**
	 * In case the Model found by the `where` argument doesn't exist, create a new Model with this data.
	 */
	create: Prisma.XOR<
		Prisma.ModelCreateInput,
		Prisma.ModelUncheckedCreateInput
	>
	/**
	 * In case the Model was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<
		Prisma.ModelUpdateInput,
		Prisma.ModelUncheckedUpdateInput
	>
}
/**
 * Model delete
 */
export type ModelDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Model
	 */
	select?: Prisma.ModelSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Model
	 */
	omit?: Prisma.ModelOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ModelInclude<ExtArgs> | null
	/**
	 * Filter which Model to delete.
	 */
	where: Prisma.ModelWhereUniqueInput
}
/**
 * Model deleteMany
 */
export type ModelDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Models to delete
	 */
	where?: Prisma.ModelWhereInput
	/**
	 * Limit how many Models to delete.
	 */
	limit?: number
}
/**
 * Model.User
 */
export type Model$UserArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the User
	 */
	select?: Prisma.UserSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the User
	 */
	omit?: Prisma.UserOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserInclude<ExtArgs> | null
	where?: Prisma.UserWhereInput
}
/**
 * Model.PresetModels
 */
export type Model$PresetModelsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the PresetModel
	 */
	select?: Prisma.PresetModelSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the PresetModel
	 */
	omit?: Prisma.PresetModelOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PresetModelInclude<ExtArgs> | null
	where?: Prisma.PresetModelWhereInput
	orderBy?:
		| Prisma.PresetModelOrderByWithRelationInput
		| Prisma.PresetModelOrderByWithRelationInput[]
	cursor?: Prisma.PresetModelWhereUniqueInput
	take?: number
	skip?: number
	distinct?:
		| Prisma.PresetModelScalarFieldEnum
		| Prisma.PresetModelScalarFieldEnum[]
}
/**
 * Model without action
 */
export type ModelDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Model
	 */
	select?: Prisma.ModelSelect<ExtArgs> | null
	/**
	 * Omit specific fields from the Model
	 */
	omit?: Prisma.ModelOmit<ExtArgs> | null
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ModelInclude<ExtArgs> | null
}
